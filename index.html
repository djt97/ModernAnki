<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Modern Editor</title>
<script src="keys.js" defer></script>
<script src="styles.js" defer></script>
<style>
/* ───── Basics ───── */
:root {
  --font-serif: 'Georgia', 'Times New Roman', serif;
  --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --bg-color: #fffff8;
  --text-color: #1a1a1a;
  --border-color: #d4d4d4;
  --highlight-inactive: rgba(255, 229, 153, 0.7); /* Soft Yellow */
  --highlight-active: rgba(255, 204, 203, 1);
  --suggestion-red: #d14;
  --suggestion-green: #22863a;
  --user-highlight: rgba(100, 149, 237, 0.3); /* Soft blue for user selection */
  --rule-style: #059669;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-serif);
  background-color: var(--bg-color);
  color: var(--text-color);
  line-height: 1.7;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* ───── Header ───── */
.header {
  position: fixed;
  top: 2rem;
  left: 0;
  z-index: 100;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: auto;
}

.hamburger-btn,
.icon-btn,
.nav-btn {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid var(--border-color);
  cursor: pointer;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.2s;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  padding: 6px;
  font-size: 1.5rem;
}

.hamburger-btn:hover, .icon-btn:hover, 
.nav-btn:hover:not(:disabled) {
  background: rgba(255, 255, 255, 1);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.icon-btn svg {
  stroke: currentColor;
}

.nav-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Correction controls */
.correction-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.nav-info {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
  text-align: center;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  color: #666;
  font-weight: 500;
}

/* Selection actions */
.selection-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.selection-btn {
  padding: 8px 12px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  white-space: nowrap;
}

.selection-btn:hover {
  background: #1d4ed8;
}

.selection-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* Main content with left margin */
.main-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 2rem;
  padding-left: 85px; /* Space for the sidebar */
  position: relative;
}

/* Responsive: ensure content doesn't overlap on narrow viewports */
@media (max-width: 600px) {
  .main-content {
    padding-left: 80px;
  }
  
  .header {
    padding: 8px;
  }
  
  .hamburger-btn,
  .icon-btn,
  .nav-btn {
    width: 36px;
    height: 36px;
  }
}


.header-actions {
  display: flex;
  gap: 8px;
}

/* Hamburger Menu */
.hamburger-menu {
  position: fixed;
  top: 0;
  left: -300px;
  width: 300px;
  height: 100vh;
  background: var(--bg-color);
  border-right: 1px solid var(--border-color);
  z-index: 1000;
  transition: left 0.3s ease;
  overflow-y: auto;
}

.hamburger-menu.open {
  left: 0;
}

.analysis-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: 100%;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.nav-arrow-group {
    display: flex;
    gap: 8px;
}

/* Styles the smaller arrow buttons within the new layout */
.nav-arrow-group .nav-btn {
    flex: 1; /* Makes both buttons share the width equally */
    width: auto; /* Overrides the default fixed width */
    height: 36px; /* Makes the buttons shorter */
    padding: 0;
    font-size: 1.2rem;
}


.menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.3);
  z-index: 999;
  display: none;
}

.menu-overlay.visible {
  display: block;
}


.menu-style-select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 0.85rem;
  margin-top: 8px;
  background: white;
}

.menu-header {
  padding: 20px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.menu-header h2 {
  font-size: 1.2rem;
  font-weight: 500;
}

.menu-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 4px 8px;
}

.menu-content {
  padding: 20px;
}

.menu-item {
  width: 100%;
  padding: 12px 16px;
  background: none;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  margin-bottom: 12px;
  cursor: pointer;
  text-align: left;
  font-size: 0.9rem;
  transition: all 0.2s;
}

.menu-item:hover {
  background: #f0f0f0;
}

.menu-divider {
  margin: 20px 0;
  border: none;
  border-top: 1px solid var(--border-color);
}

.menu-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  cursor: pointer;
  font-size: 0.9rem;
}

.menu-toggle input {
  cursor: pointer;
}

.menu-select-group {
  margin-top: 16px;
  padding: 0 16px;
}

.menu-select-group label {
  display: block;
  margin-bottom: 8px;
  font-size: 0.9rem;
  color: #666;
}

.menu-select-group select {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 0.9rem;
}

.analyze-btn {
  padding: 8px 12px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  white-space: nowrap;
  width: 100%; /* Make them fill the sidebar width */
}

.analyze-btn:hover {
  background: #111;
}

.correction-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.correction-actions .popover-btn {
  width: 100%;
  padding: 8px; /* Give them more vertical space */
}

.control-label {
    font-size: 0.8rem;
    color: #666;
    font-family: var(--font-sans);
}

.api-key-input {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  background: white;
  color: var(--text-color);
  -webkit-appearance: none;
  appearance: none;
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.25em;
  padding-right: 2rem;
  width: 200px;
  background-image: none;
}


/* ───── Main Content Layout ───── */
.editor-wrapper {
  max-width: 80ch;
  margin: 0 auto;
  position: relative;
}

/* ───── Editor & Highlight Overlay ───── */
.editor-textarea, .highlight-overlay {
  width: 100%;
  min-height: 50vh;
  padding: 1rem;
  font-family: var(--font-serif);
  font-size: 18px;
  line-height: 1.7;
  border: 1px solid transparent;
  background: transparent;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
  color: var(--text-color);
}

/* Default: normal page flow (no inner scroll, no overlay stacking) */
.editor-textarea {
  position: relative;
  top: auto;
  left: auto;
  height: auto;
  resize: none;
  outline: none;
  z-index: 2;
  color: var(--text-color);
  overflow: hidden; /* let the PAGE scroll, not the textarea */
}

/* Only when overlay/highlights are active do we stack it over the overlay */
.overlay-active .editor-textarea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  overflow: hidden; /* no inner scroll while overlay is active */
  color: transparent;
  caret-color: var(--text-color);
}

/* Hide duplicate foreground text when overlay highlights are active */
.overlay-active .editor-textarea::selection {
  background: rgba(38,132,255,.25);
}

.overlay-active .highlight-overlay { display: block; }

.highlight-overlay {
  position: relative;
  z-index: 1;
  pointer-events: none;
  display: none;
}

/* ───── Suggestion Highlighting ───── */
.suggestion {
  background-color: var(--highlight-inactive);
  border-radius: 3px;
  cursor: pointer;
  pointer-events: all;
  transition: background-color 0.3s;
  scroll-margin-bottom: 110px; 
}

.suggestion.active {
  background-color: var(--highlight-active);
}

.suggestion .badge {
  font-size: 0.75em;
  margin-left: 4px;
  vertical-align: super;
  opacity: 0.8;
}

/* ───── User Selection Highlighting ───── */
.user-selection {
  background-color: var(--user-highlight);
  border-radius: 3px;
  position: relative;
}

/* ───── Suggestion Popover ───── */
.suggestion-popover {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10;
  background: rgba(255, 255, 248, 0.98);
  border-top: 2px solid #ccc;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
  padding: 16px 20px; 
  font-family: var(--font-sans);
  font-size: 0.9rem;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}

.suggestion-popover.visible {
  transform: translateY(0);
}


.selection-disabled-hint {
  color: var(--suggestion-red);
  font-style: italic;
  font-size: 0.8rem;
  margin: 0 auto; /* Center it a bit */
  display: none; /* Hidden by default */
}

.popover-counter {
  position: absolute;
  top: 10px;
  right: 20px;
  font-size: 0.85rem;
  color: #666;
  font-weight: 500;
}

.popover-diff {
  font-size: 1rem;
  line-height: 1.6;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  max-width: 800px;
  margin: 0 auto;
}

.popover-actions {
  margin-top: 16px;
  display: flex;
  gap: 12px;
  justify-content: center;
  max-width: 400px;
  margin: 16px auto 0;
}

.popover-explanation {
  font-style: italic;
  color: #555;
  margin-bottom: 16px;
  text-align: center;
  max-width: 800px;
  margin: 0 auto 16px;
}

.popover-diff del {
  color: var(--suggestion-red);
  text-decoration: none;
  background-color: #ffebe9;
  padding: 2px 4px;
  border-radius: 3px;
}

.popover-diff ins {
  color: var(--suggestion-green);
  text-decoration: none;
  background-color: #e6ffed;
  padding: 2px 4px;
  border-radius: 3px;
}

.popover-btn {
  padding: 4px 16px;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  background: white;
  font-size: 0.8rem;
  transition: all 0.2s;
}

.popover-btn.accept:hover {
  background: #e6ffed;
  border-color: var(--suggestion-green);
  color: var(--suggestion-green);
}
.popover-btn.reject:hover {
  background: #ffebe9;
  border-color: var(--suggestion-red);
  color: var(--suggestion-red);
}

/* Re-generate hint box */
.popover-tools {
  max-width: 800px;
  margin: 12px auto 0;
  display: flex;
  justify-content: center;
}
.regen-hint-input {
  width: 100%;
  max-width: 600px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 6px 10px;
  font-size: 0.9rem;
  font-family: var(--font-sans);
  background: #fff;
}

/* ───── Summary Modal (used for proofs and simplifications) ───── */
.summary-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 600px;
  max-width: 90vw;
  max-height: 80vh;
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 24px;
  font-family: var(--font-sans);
  overflow-y: auto;
  z-index: 100;
  display: none;
}

.summary-modal.visible {
  display: block;
}

.summary-modal h2 {
  font-size: 1.3rem;
  margin-bottom: 16px;
  font-weight: 500;
}

.summary-section {
  margin-bottom: 20px;
}

.summary-section h3 {
  font-size: 1rem;
  font-weight: 600;
  color: #444;
  margin-bottom: 8px;
}

.summary-section p,
.summary-section ul {
  color: #666;
  line-height: 1.6;
}

.summary-section ul {
  margin-left: 20px;
}

.locked {
  pointer-events: none;
}

.simplification-option {
  margin-bottom: 16px;
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  transition: all 0.2s;
  cursor: pointer;
}

.simplification-option:hover {
  background: #f8f8f8;
  border-color: #999;
}

.simplification-label {
  font-weight: 600;
  color: #444;
  margin-bottom: 4px;
  font-size: 0.85rem;
}

.simplification-text {
  color: #222;
  line-height: 1.6;
}

.summary-close {
  position: absolute;
  top: 16px;
  right: 16px;
  background: none;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: #666;
  padding: 4px 8px;
}

.summary-close:hover {
  color: #222;
}

.popover-diff ins[contenteditable="true"]:focus {
  outline: 1px solid #888;
  box-shadow: 0 0 3px rgba(0,0,0,0.1);
  background-color: #fff; /* Make background solid white on focus for better editing */
}

/* ───── Modal Overlay ───── */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  z-index: 99;
  display: none;
}

.modal-overlay.visible {
  display: block;
}

.regen-area {
  width: 100%;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 10px;
  font-family: var(--font-sans);
  font-size: 0.95rem;
  background: #fff;
  margin: 8px 0 12px;
}
.regen-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

/* ───── Loading & Empty State ───── */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 248, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  font-family: var(--font-sans);
}

.loading-content { text-align: center; }
.loading-spinner {
  border: 2px solid #ccc;
  border-top: 2px solid #333;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  animation: spin 1s linear infinite;
  margin: 0 auto 16px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.loading-text { font-size: 0.9rem; color: #666; font-style: italic; }

.empty-state {
    text-align: center;
    padding: 4rem 1rem;
    color: #888;
    font-family: var(--font-sans);
}
.empty-state h3 { font-weight: 500; font-size: 1.1rem; }
.empty-state p { font-style: italic; margin-top: 0.5rem; }

/* ───── About Modal ───── */
.about-modal {
  position: fixed;
  /* Instead of centering perfectly, pin near the top so header never clips */
  top: 5vh;
  left: 50%;
  transform: translateX(-50%);
  width: 1200px;
  max-width: 90vw;

  /* Key bits so long content is readable */
  max-height: 90vh;
  overflow-y: auto;
  scrollbar-gutter: stable both-edges;
  overscroll-behavior: contain;

  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 100;
  display: none;
}

.about-modal.visible {
  display: block;
}

.about-modal h2 {
  font-size: 1.4rem;
  margin-bottom: 20px;
  font-weight: 500;
}

.about-modal h3 {
  font-size: 1.1rem;
  margin-top: 20px;
  margin-bottom: 10px;
  font-weight: 600;
  color: #444;
}

.about-modal p {
  line-height: 1.6;
  color: #666;
  margin-bottom: 12px;
}

.about-modal ul {
  margin-left: 20px;
  color: #666;
  line-height: 1.8;
}

.about-modal a {
  color: #2563eb;
  text-decoration: none;
}

.about-modal a:hover {
  text-decoration: underline;
}

/* ───── File Upload Modal ───── */
.file-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  max-width: 90vw;
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 100;
  display: none;
}

.file-modal.visible {
  display: block;
}

.file-modal h2 {
  font-size: 1.2rem;
  margin-bottom: 20px;
  font-weight: 500;
  text-align: center;
}

.drop-zone {
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 40px;
  text-align: center;
  transition: all 0.3s;
  cursor: pointer;
  background: #fafafa;
}

.drop-zone:hover {
  border-color: #999;
  background: #f5f5f5;
}

.drop-zone.dragging {
  border-color: #2563eb;
  background: #e0e7ff;
}

.drop-zone p {
  color: #666;
  margin-bottom: 16px;
}

.file-input {
  display: none;
}

.file-btn {
  padding: 8px 20px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.2s;
}

.file-btn:hover {
  background: #111;
}
.api-key-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 1001;
  text-align: center;
  max-width: 400px;
  width: 90%;
}

.api-key-modal h2 {
  font-size: 1.2rem;
  margin-bottom: 12px;
  font-weight: 500;
}

.api-key-modal p {
  color: #666;
  margin-bottom: 20px;
  font-size: 0.9rem;
  line-height: 1.5;
}

.api-key-modal input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.9rem;
  margin-bottom: 16px;
  font-family: monospace;
}

.api-key-modal button {
  padding: 8px 24px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.2s;
}

.api-key-modal button:hover {
  background: #111;
}

/* ───── Flashcards Panel ───── */
.flashcards-section {
  max-width: 80ch;
  margin: 2rem auto 0;
  border: 1px dashed var(--border-color);
  background: rgba(255,255,255,0.6);
  border-radius: 6px;
  padding: 12px;
}
.flashcards-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-family: var(--font-sans);
}
.flashcards-output {
  width: 100%;
  min-height: 140px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  padding: 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: #fff;
  color: #222;
  resize: vertical;
}

.flashcards-prefs {
  display: flex;
  align-items: center;
  gap: 8px;
  font-family: var(--font-sans);
  font-size: 0.85rem;
}
.flashcards-prefs select {
  padding: 4px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: #fff;
}
.flashcards-prefs input[type="checkbox"] {
  transform: translateY(1px);
}

/* Make both sides editable look consistent */
.popover-diff del[contenteditable="true"]:focus,
.popover-diff ins[contenteditable="true"]:focus {
  outline: 1px solid #888;
  box-shadow: 0 0 3px rgba(0,0,0,0.1);
  background-color: #fff;
}

/* Label the popover fields as Front and Back when we're using flashcards */
.popover-diff del::before {
  content: 'Front: ';
  font-weight: 600;
  color: #666;
}
.popover-diff ins::before {
  content: 'Back: ';
  font-weight: 600;
  color: #666;
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <button class="hamburger-btn" id="hamburgerBtn">☰</button>
  <button class="nav-btn icon-btn" id="copyBtn" title="Copy Text">
    <svg class="icon-copy" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
    <svg class="icon-check" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><polyline points="20 6 9 17 4 12"></polyline></svg>
  </button>
  <button class="nav-btn icon-btn" id="downloadBtn" title="Download as .txt">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
  </button>

  <!-- Wrapper for analysis button to add the line above -->
  <div class="analysis-controls">
  <button class="selection-btn analyze-btn" id="analyzeFlashcardsBtn">Flashcards</button>
  </div>


  <!-- Navigation controls (visible during corrections) -->
  <div class="correction-controls" id="correctionControls" style="display: none;">
    <div class="nav-info" id="navInfo">0 / 0</div>
    <!-- Wrapper for side-by-side arrows -->
    <div class="nav-arrow-group">
        <button class="nav-btn" id="prevBtn">←</button>
        <button class="nav-btn" id="nextBtn">→</button>
        <button class="nav-btn" id="undoBtn" title="Undo Last Action (⎌)" style="display: none;">⎌</button>
        <button class="nav-btn" id="redoBtn" title="Redo Last Undo (⇧⌘Z / Ctrl+Shift+Z)" style="display: none;">⤻</button>
    </div>
    <!-- Accept/Reject buttons are now correctly inside this container -->
    <div class="correction-actions">
        <button class="popover-btn reject" id="popoverRejectBtn">Reject</button>
        <button class="popover-btn accept" id="popoverAcceptBtn">Accept</button>
        <button class="popover-btn" id="regenBtn" title="Re-generate variants based on hint">↻ Re‑generate</button>
        <button class="popover-btn" id="splitBtn" title="Split this card into exactly two atomic cards">Split (2)</button>
        <button class="popover-btn" id="reverseBtn" title="Generate a reversed version of this card">Reverse</button>
        <button class="popover-btn" id="newFromHighlightBtn" title="Create a NEW card using this highlight and your hint">＋ New from Highlight</button>
    </div>
  </div>
  
  <!-- Selection actions (visible when text selected) -->
  <div class="selection-actions" id="selectionActions" style="display: none;">
    <button class="selection-btn" id="simplifyBtn">Simplify</button>
    <button class="selection-btn" id="proofBtn">Check Proof</button>
    <button class="selection-btn" id="makeCardBtn">Make Card</button>
  </div>
</div>

<!-- Hamburger Menu -->
<div class="hamburger-menu" id="hamburgerMenu">
  <div class="menu-header">
    <h2>Modern Editor</h2>
    <button class="menu-close" id="menuClose">×</button>
  </div>
  <div class="menu-content">
    <button class="menu-item" id="helpBtn" style="background-color:#000000; color:#FFFFFF;">Help</button>
    <hr class="menu-divider">
    <button class="menu-item" id="newDocBtn">Load New Document</button>
    <hr class="menu-divider">
    <div class="menu-select-group">
    <select id="ruleSelect" style="display: none;">
      <!-- Options will be populated from rules.js -->
    </select>
    <div class="menu-select-group">
      <label for="languageSelect">Language:</label>
      <select id="languageSelect">
        <option value="en-US">English (US)</option>
        <option value="en-CAN">English (CAN)</option>
        <option value="en-UK">English (UK)</option>
        <option value="fr">French</option>
        <option value="es">Spanish</option>
        <option value="de">German</option>
      </select>
    </div>
    <div class="menu-select-group">
      <label for="styleSelect">Flashcard Domain:</label>
      <select id="styleSelect" class="menu-style-select">
        <!-- Options will be populated from rules.js -->
      </select>
    </div>
    <div class="menu-select-group">
      <label for="depthSelect">Flashcard Depth:</label>
      <select id="depthSelect">
        <option value="shallow">Shallow</option>
        <option value="medium" selected>Medium</option>
        <option value="complete">Complete</option>
      </select>
    </div>
    <label class="menu-toggle">
      <input type="checkbox" id="freeModelsCheckbox">
      <span>Use free LLM models only</span>
    </label>
    </div>
  </div>
</div>
<div class="menu-overlay" id="menuOverlay"></div>

<!-- Main Content -->
<main class="main-content" id="mainContent">
  <div class="editor-wrapper">
    <div class="highlight-overlay" id="highlightOverlay"></div>
    <textarea class="editor-textarea" id="documentInput" placeholder="Paste or write your document here..."></textarea>
  </div>

  <!-- Accepted Flashcards Panel -->
  <section class="flashcards-section" id="flashcardsSection">
    <div class="flashcards-header">
      <h3>Accepted Flashcards</h3>
      <div class="flashcards-actions">
        <button class="nav-btn icon-btn" id="copyFlashcardsBtn" title="Copy Flashcards">
          <!-- reuse the clipboard icon -->
          <svg class="icon-copy" xmlns="http://www.w3.org/2000/svg" width="16" height="16"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
        <button class="nav-btn icon-btn" id="downloadFlashcardsBtn" title="Download flashcards (.txt)">
          <!-- reuse the download icon -->
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        </button>
      </div>
    </div>
     <!-- ADD THIS PREFERENCES BAR -->
    <div class="flashcards-prefs" style="margin-bottom:8px;">
      <label for="exportStyleSelect" class="control-label">Export:</label>
      <select id="exportStyleSelect">
        <option value="neuracache">Neuracache</option>
        <option value="anki">Anki</option>
        <option value="remnote">Remnote</option>
        <option value="raw">Raw (Front ⏎ Back)</option>
      </select>

      <label for="includeSourceCheckbox" class="control-label" style="margin-left:12px;">
        <input type="checkbox" id="includeSourceCheckbox"> Include source material
      </label>
    </div>

    <textarea id="flashcardsOutput" class="flashcards-output"
      placeholder="Export preview appears here (changes with preferences above)."
      readonly></textarea>
  </section>
</main>


<!-- Suggestion Popover -->
<div class="suggestion-popover" id="suggestionPopover">
  <div class="popover-explanation" id="popoverExplanation"></div>
  <div class="popover-diff">
    <del id="popoverOriginal"></del> 
    → 
    <ins id="popoverCorrected" contenteditable="true"></ins>
  </div>
</div>

<!-- Simplification Modal -->
<div class="modal-overlay" id="simplificationOverlay"></div>
<div class="summary-modal" id="simplificationModal">
  <button class="summary-close" id="simplificationModalClose">×</button>
  <h2>Simplification Options</h2>
  <div class="summary-section">
    <h3>Original Text</h3>
    <p id="simplificationOriginal" style="background: #f5f5f5; padding: 12px; border-radius: 4px; font-style: italic;"></p>
  </div>
  <div id="simplificationOptions"></div>
</div>

<!-- Action Hint Modal (replaces the old 'regen' modal) -->
<!-- Note: ensure regenOverlay, Modal, Close, HintArea etc. are all relabeled! -->
<div class="modal-overlay" id="actionOverlay"></div>
<div class="summary-modal" id="actionModal">
  <button class="summary-close" id="actionClose">×</button>
  <h2 id="actionTitle">Action</h2>
  <p class="control-label" id="actionPrompt">Optional instructions:</p>
  <textarea id="actionHintArea" class="regen-area" rows="4"></textarea>
  <div class="regen-actions">
    <button class="popover-btn" id="actionCancel">Cancel</button>
    <button class="popover-btn accept" id="actionSubmit">Submit</button>
  </div>
</div>


<!-- Loading overlay -->
<div class="loading-overlay" id="loadingOverlay" style="display: none;">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Analyzing...</div>
  </div>
</div>

<!-- Summary Modal -->
<div class="modal-overlay" id="modalOverlay"></div>
<div class="summary-modal" id="summaryModal">
  <button class="summary-close" id="summaryClose">×</button>
  <h2>Document Summary</h2>
  <div id="summaryContent"></div>
</div>

<!-- About Modal -->
<div class="modal-overlay" id="aboutOverlay"></div>
<div class="about-modal" id="aboutModal">
  <button class="summary-close" id="aboutClose">×</button>

  <h2>Flashcard Generator (September 2025)</h2>
  <p>Created by <strong>DJ Thornton</strong><br>
     Postdoctoral Research Fellow, Manos Institute for Cognitive Economics, UNSW Sydney</p>

  <!-- CREDIT WHERE CREDIT IS DUE! -->
  <p style="margin-top:-6px;">
    <em>A huge thanks to <a href="https://kevinbryanecon.com/ModernEditor/" target="_blank">Kevin Bryan’s Modern Editor</a> for inspiring this project.</em>
  </p>

  <p>
    <a href="https://djthornton.org" target="_blank">djthornton.org</a><br>
    <a href="mailto:d.thornton@unsw.edu.au">d.thornton@unsw.edu.au</a>
  </p>

  <h3>What this app does</h3>
  <ul>
    <li><strong>Generate flashcards from text:</strong> The model creates Q/A cards anchored to exact source snippets so you can trace every card back to the document.</li>
    <li><strong>Accept / Reject cards:</strong> Quickly curate only the cards you want. Accepted cards accumulate in the panel at the bottom (ready to copy/download).</li>
  </ul>

  <h3>Editing tools on each card</h3>
  <ul>
    <li><strong>↻ Regenerate:</strong> Rewrites the current card using your instructions (modal). Replaces the card in place.</li>
    <li><strong>Split (2):</strong> Splits one card into exactly two atomic cards. Replaces the original with the first split and inserts the second right after.</li>
    <li><strong>Reverse:</strong> Creates an additional, reversed card (original stays). Avoids meta “what question would…” wording.</li>
    <li><strong>＋ New from Highlight:</strong> Always opens a prompt box. Uses the highlighted source + current card as context to create a <em>new</em> related card (e.g., request a definition or acronym expansion).</li>
  </ul>

  <h3>Make a card from selected text</h3>
  <ul>
    <li><strong>Make Card:</strong> Select any text in the editor and click <em>Make Card</em> (in the left panel) to generate cards strictly from the selection (context is used only to disambiguate).</li>
  </ul>

  <h3>Keyboard shortcuts</h3>
  <ul>
    <li><strong>← / →</strong>: Navigate cards</li>
    <li><strong>Enter</strong>: Accept current flashcard</li>
    <li><strong>Backspace / Delete</strong>: Reject current flashcard</li>
    <li><strong>⎌ (button)</strong>: Undo last action &nbsp;•&nbsp; <strong>⇧⌘Z / Ctrl+Shift+Z</strong>: Redo</li>
    <li><strong>s</strong>: Split (immediate) &nbsp;•&nbsp; <strong>Ctrl/⌘+s</strong>: Split with modal hint</li>
    <li><strong>r</strong>: Reverse (immediate) &nbsp;•&nbsp; <strong>Ctrl/⌘+r</strong>: Reverse with modal hint</li>
    <li><strong>a</strong>: Regenerate (opens modal)</li>
    <li><strong>n</strong>: New from Highlight (opens modal)</li>
  </ul>

  <p style="color:#666; font-size:0.9rem;">
    Tips: Keep each card <em>atomic</em> (one idea on the back) and <em>univocal</em> (a single correct answer on the front). Markdown/LaTeX is supported in both fields.
  </p>
</div>


<!-- File Upload Modal -->
<div class="modal-overlay" id="fileOverlay"></div>
<div class="file-modal" id="fileModal">
  <button class="summary-close" id="fileClose">×</button>
  <h2>Open File</h2>
  <div class="drop-zone" id="dropZone">
    <p>Drag and drop a .tex or .txt file here</p>
    <p style="margin-bottom: 8px; font-size: 0.9rem;">or</p>
    <button class="file-btn" id="fileSelectBtn">Choose File</button>
    <input type="file" class="file-input" id="fileInput" accept=".tex,.txt">
  </div>
</div>

<!-- API Key Modal -->
<div class="api-key-modal" id="apiKeyModal" style="display: none;">
  <h2>Model Provider</h2>
  <p>Select a provider and enter an API key. Keys are stored locally in your browser.</p>

  <label for="providerSelect" style="display:block; text-align:left; margin-bottom:6px;">Provider:</label>
  <select id="providerSelect" style="width:100%; padding:8px; margin-bottom:12px;">
    <option value="gemini">Gemini</option>
    <option value="ultimateai">UltimateAI</option>
  </select>

  <div id="geminiFields">
    <p style="margin:0 0 6px;">Gemini key:</p>
    <input type="text" id="apiKeyInput" placeholder="Enter your Gemini API key">
    <p style="font-size:0.85rem; color:#666; margin-top:8px;">
      Get a key at https://aistudio.google.com/app/apikey
    </p>
  </div>

  <div id="ultimateFields" style="display:none;">
    <p style="margin:10px 0 6px;">UltimateAI key:</p>
    <input type="text" id="ultimateKeyInput" placeholder="Enter your UltimateAI key">
    <p style="margin:10px 0 6px;">UltimateAI model (e.g., gpt-4o-mini):</p>
    <input type="text" id="ultimateModelInput" placeholder="Enter the model name">
    <p style="font-size:0.85rem; color:#666; margin-top:8px;">
      Base URL: https://smart.ultimateai.org/v1 — Chat Completions: /chat/completions
    </p>
  </div>

  <button id="apiKeySubmit">Continue</button>
</div>

<script>
// State management
let corrections = [];
let currentIndex = -1;
let undoStack = [];
let redoStack = [];
let apiKey = '';
let selectedText = '';
let selectedRange = null;
let selectionMode = false;
let acceptedFlashcards = [];

// DOM elements
const undoBtn = document.getElementById('undoBtn');
const documentInput = document.getElementById('documentInput');
const highlightOverlay = document.getElementById('highlightOverlay');
const mainContent = document.getElementById('mainContent');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const navInfo = document.getElementById('navInfo');
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');
const ruleSelect = document.getElementById('ruleSelect');
const simplificationModal = document.getElementById('simplificationModal');
const simplificationOriginal = document.getElementById('simplificationOriginal');
const simplificationOptions = document.getElementById('simplificationOptions');
const simplificationModalClose = document.getElementById('simplificationModalClose');
const simplificationOverlay = document.getElementById('simplificationOverlay');
const summaryModal = document.getElementById('summaryModal');
const summaryContent = document.getElementById('summaryContent');
const summaryClose = document.getElementById('summaryClose');
const modalOverlay = document.getElementById('modalOverlay');
const apiKeyModal = document.getElementById('apiKeyModal');
const apiKeyInput = document.getElementById('apiKeyInput');
const apiKeySubmit = document.getElementById('apiKeySubmit');
const aboutModal = document.getElementById('aboutModal');
const aboutClose = document.getElementById('aboutClose');
const aboutOverlay = document.getElementById('aboutOverlay');
const fileModal = document.getElementById('fileModal');
const fileClose = document.getElementById('fileClose');
const fileOverlay = document.getElementById('fileOverlay');
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const fileSelectBtn = document.getElementById('fileSelectBtn');
const selectionActions = document.getElementById('selectionActions');
const simplifyBtn = document.getElementById('simplifyBtn');
const proofBtn = document.getElementById('proofBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const styleSelect = document.getElementById('styleSelect');
const correctionControls = document.getElementById('correctionControls');
const flashcardsOutput = document.getElementById('flashcardsOutput');
const copyFlashcardsBtn = document.getElementById('copyFlashcardsBtn');
const downloadFlashcardsBtn = document.getElementById('downloadFlashcardsBtn');
const depthSelect = document.getElementById('depthSelect');
const makeCardBtn = document.getElementById('makeCardBtn');
const regenBtn = document.getElementById('regenBtn');
const splitBtn = document.getElementById('splitBtn');
const reverseBtn = document.getElementById('reverseBtn');
const providerSelect = document.getElementById('providerSelect');
const geminiFields = document.getElementById('geminiFields');
const ultimateFields = document.getElementById('ultimateFields');
const ultimateKeyInput = document.getElementById('ultimateKeyInput');
const ultimateModelInput = document.getElementById('ultimateModelInput');
const actionOverlay  = document.getElementById('actionOverlay');
const actionModal    = document.getElementById('actionModal');
const actionClose    = document.getElementById('actionClose');
const actionHintArea = document.getElementById('actionHintArea');
const actionCancel   = document.getElementById('actionCancel');
const actionSubmit   = document.getElementById('actionSubmit');
const actionTitle    = document.getElementById('actionTitle');
const actionPrompt   = document.getElementById('actionPrompt');
const redoBtn = document.getElementById('redoBtn');
const newFromHighlightBtn = document.getElementById('newFromHighlightBtn');
const exportStyleSelect     = document.getElementById('exportStyleSelect');
const includeSourceCheckbox = document.getElementById('includeSourceCheckbox');

let pendingAction = null; // 'regenerate' | 'split' | 'reverse'

// Hamburger elements
const hamburgerBtn = document.getElementById('hamburgerBtn');
const hamburgerMenu = document.getElementById('hamburgerMenu');
const menuClose = document.getElementById('menuClose');
const menuOverlay = document.getElementById('menuOverlay');
const helpBtn = document.getElementById('helpBtn');
const newDocBtn = document.getElementById('newDocBtn');
const analyzeFlashcardsBtn = document.getElementById('analyzeFlashcardsBtn');


// Popover elements
const suggestionPopover = document.getElementById('suggestionPopover');
const popoverExplanation = document.getElementById('popoverExplanation');
const popoverOriginal = document.getElementById('popoverOriginal');
const popoverCorrected = document.getElementById('popoverCorrected');
const popoverAcceptBtn = document.getElementById('popoverAcceptBtn');
const popoverRejectBtn = document.getElementById('popoverRejectBtn');

// Hamburger menu events
hamburgerBtn.addEventListener('click', openHamburgerMenu);
menuClose.addEventListener('click', closeHamburgerMenu);
menuOverlay.addEventListener('click', closeHamburgerMenu);

styleSelect.addEventListener('change', () => {
  const rule = window.WRITING_RULES[styleSelect.value];
  if (rule && (rule.type === 'flashcard' || rule.type === 'style')) {
    ruleSelect.value = styleSelect.value;
  }
});

helpBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  showAboutModal();
});

undoBtn.addEventListener('click', handleUndo);

newDocBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  showFileModal();
});

analyzeFlashcardsBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  // Use whatever is selected in the domain dropdown; fallback to a base flashcard rule
  const candidate = window.WRITING_RULES[styleSelect.value];
  ruleSelect.value = (candidate && candidate.type === 'flashcard') ? styleSelect.value : 'flashcards_base';
  handleAnalysis();
});


copyFlashcardsBtn.addEventListener('click', () => {
  const text = renderExport();
  navigator.clipboard.writeText(text || '')
    .catch(err => { console.error('Failed to copy flashcards:', err); alert('Failed to copy flashcards.'); });
});

downloadFlashcardsBtn.addEventListener('click', () => {
  const text = renderExport() || '';
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'flashcards.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

makeCardBtn.addEventListener('click', handleMakeCardFromSelection);

if (redoBtn) redoBtn.addEventListener('click', handleRedo);

function openHamburgerMenu() {
  hamburgerMenu.classList.add('open');
  menuOverlay.classList.add('visible');
  
  // If current rule is a style, update style selector
  if (ruleSelect && ruleSelect.value && window.WRITING_RULES) {
    const currentRule = window.WRITING_RULES[ruleSelect.value];
    if (currentRule && (currentRule.type === 'flashcard' || currentRule.type === 'style') && styleSelect) {
  styleSelect.value = ruleSelect.value;
    }
  }
}

function closeHamburgerMenu() {
  hamburgerMenu.classList.remove('open');
  menuOverlay.classList.remove('visible');
}

// Pure string formatters (no model calls)
const EXPORTERS = {
  neuracache(cards) {
    // front #flashcard \n back \n\n
    return cards.map(c => `${c.front} #flashcard\n${c.back}`).join('\n\n');
  },
  anki(cards) {
    // Q: front \n A: back \n\n
    return cards.map(c => `Q: ${c.front}\nA: ${c.back}`).join('\n\n');
  },
  remnote(cards) {
    // front >> back \n\n
    return cards.map(c => `${c.front} >> ${c.back}`).join('\n\n');
  },
  raw(cards) {
    // front \n back \n\n
    return cards.map(c => `${c.front}\n${c.back}`).join('\n\n');
  }
};

// Compose final export string based on current UI prefs
function renderExport() {
  const styleKey = (exportStyleSelect?.value) || localStorage.getItem('exportStyle') || 'neuracache';
  const formatter = EXPORTERS[styleKey] || EXPORTERS.neuracache;

  const includeSource = (includeSourceCheckbox?.checked !== undefined)
    ? includeSourceCheckbox.checked
    : JSON.parse(localStorage.getItem('exportIncludeSource') || 'false');

  let out = formatter(acceptedFlashcards || []);

  if (includeSource) {
    const src = documentInput.value || '';
    out = `## Source Material\n${src}\n\n## Flashcards\n${out}`;
  }
  return out;
}

function updateFlashcardsOutput() {
  if (!flashcardsOutput) return;
  flashcardsOutput.value = renderExport();
}

function generateSelectionFlashcardPrompt(selection, context, rule) {
  const languageInstruction = getLanguageInstruction();
  const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
  const depthInstruction = (depth === 'shallow')
    ? 'Return at most 2 cards for the selection.'
    : (depth === 'complete')
      ? 'Return 1–3 cards; prefer splitting into atomic cards if multiple ideas appear.'
      : 'Return 1–2 cards.';

  const domainFragment = (rule && rule.prompt) ? rule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
Create flashcards ONLY from the SELECTED text (use its CONTEXT only to disambiguate).
Atomicity & univocality required. Allow Markdown/LaTeX. Include a "source" snippet copied verbatim from the selection if possible; otherwise from the immediate context.

${depthInstruction}

Domain guidance:
${domainFragment}

Return ONLY a JSON array of 1–3 objects with keys: source, front, back, explanation (optional).

SELECTION:
\`\`\`
${selection}
\`\`\`

CONTEXT (may be used for source if needed):
\`\`\`
${context}
\`\`\`
`;
}

function generateRegenerateCardPrompt(card, hint, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  // Grab local context around the anchored span for better phrasing
  const fullText = documentInput.value;
  const ctxStart = Math.max(0, card.position.start - 400);
  const ctxEnd   = Math.min(fullText.length, card.position.end + 400);
  const context  = fullText.substring(ctxStart, ctxEnd);

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
We have an existing FLASHCARD (front/back) anchored to a source snippet. Please propose up to THREE alternative versions that better satisfy:
- Atomicity: one coherent idea per back.
- Univocality: front has a single unambiguous answer.
- Keep notation precise; allow Markdown/LaTeX ($...$ or \\[ ... \\]).

If the user hint is provided, follow it strictly: "${hint || '(no hint)'}".

Domain guidance:
${domainFragment}

Return ONLY a JSON array of 1–3 objects with keys:
- "source": short verbatim snippet (<=160 chars) from the DOCUMENT or CONTEXT (prefer original source).
- "front": revised prompt/question (may include Markdown/LaTeX).
- "back": revised answer (a single idea; may include Markdown/LaTeX).
- "explanation": optional short rationale.

DOCUMENT CONTEXT (for anchoring and wording):
\`\`\`
${context}
\`\`\`

CURRENT CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}
`;
}

function generateSplitCardPrompt(card, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
SPLIT the following FLASHCARD into EXACTLY TWO atomic cards. Keep univocal fronts, one-idea backs. Preserve notation; allow Markdown/LaTeX.

Domain guidance:
${domainFragment}

Return ONLY a JSON array with EXACTLY TWO objects:
[
  { "source": "verbatim snippet (<=160 chars)",
    "front": "univocal prompt",
    "back": "single idea answer",
    "explanation": "optional"
  },
  { ... second card ... }
]

CURRENT CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}
`;
}

function generateReverseCardPrompt(card, domainRule, userHint='') {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
  Create a REVERSED flashcard that asks for the ORIGINAL FRONT given the ORIGINAL BACK.

  Hard constraints:
  - The new FRONT must be a natural question a student could see on a test.
  - Do NOT write meta-questions about "what question would..." or "given the answer".
  - Do NOT mention "answer" or "question" explicitly.
  - Keep fronts univocal (single correct answer). Keep backs atomic (one idea).
  - Preserve notation; Markdown/LaTeX allowed ($...$ or \\[...\\]).
  - If the original FRONT contains "types of X", "examples of X", or "definition of X", prefer forms like "Y and Z are both examples of what?" or "What is X?".

  ${userHint ? `User hint: ${userHint}` : ''}

  Domain guidance:
  ${domainFragment}

  Return ONLY a JSON object:
  {
    "source": "verbatim snippet (<=160 chars) from the document (prefer original source)",
    "front":  "reversed prompt (no meta language)",
    "back":   "single-idea answer",
    "explanation": "optional"
  }

  ORIGINAL CARD:
  {
    "source": "${(card.source || '').replace(/"/g, '\\"')}",
    "front": "${(card.front || '').replace(/"/g, '\\"')}",
    "back": "${(card.back || '').replace(/"/g, '\\"')}"
  }
  `;
}

function generateNewFromHighlightPrompt(card, userHint, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  // Local context around the anchor to help the model compose the new card
  const fullText = documentInput.value;
  const ctxStart = Math.max(0, card.position.start - 500);
  const ctxEnd   = Math.min(fullText.length, card.position.end + 500);
  const context  = fullText.substring(ctxStart, ctxEnd);

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
Create a NEW flashcard based on the highlighted SOURCE and the EXISTING card shown below.
Use the user's hint strictly to guide what new knowledge to target.

Hard constraints:
- Atomicity: the new BACK must contain a single idea.
- Univocality: the new FRONT must imply a single correct answer.
- Preserve notation; Markdown/LaTeX allowed.
- Do not merely rephrase the existing card; produce a distinct, useful card.
- Prefer fronts that could appear on a test.

User hint: "${userHint || '(no hint provided)'}"

Domain guidance:
${domainFragment}

Return ONLY a JSON object OR a one-element JSON array with keys:
{
  "source": "verbatim snippet (<=160 chars) from the DOCUMENT (prefer the same highlight if appropriate)",
  "front":  "new prompt/question",
  "back":   "new single-idea answer",
  "explanation": "optional"
}

DOCUMENT CONTEXT:
\`\`\`
${context}
\`\`\`

EXISTING CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}`;
}

async function handleMakeCardFromSelection() {
  if (!selectedText || !selectedRange) return;

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Generating card...';

    // Use the currently chosen domain rule if set
    const chosen = window.WRITING_RULES[ruleSelect.value] || window.WRITING_RULES['flashcards_base'];
    const model = getModelForType('flashcard');

    const fullText = documentInput.value;
    const ctxStart = Math.max(0, selectedRange.start - 400);
    const ctxEnd   = Math.min(fullText.length, selectedRange.end + 400);
    const context  = fullText.substring(ctxStart, ctxEnd);

    const prompt = generateSelectionFlashcardPrompt(selectedText, context, chosen);
    const results = await callLLMAPI(prompt, model);

    const arr = Array.isArray(results) ? results : [];
    if (arr.length === 0) {
      alert('No card generated for the selection.');
      return;
    }

    // Normalize and insert as suggestions anchored to the selection range
    arr.forEach(obj => {
      const card = {
        type: 'flashcard',
        source: (typeof obj.source === 'string' && obj.source.length > 0) ? obj.source : selectedText.slice(0, 160),
        front:  (typeof obj.front  === 'string') ? obj.front  : '',
        back:   (typeof obj.back   === 'string') ? obj.back   : '',
        explanation: (typeof obj.explanation === 'string') ? obj.explanation : '',
        position: { start: selectedRange.start, end: selectedRange.end }
      };
      corrections.push(card);
    });

    // Clear user selection so the suggestion highlight is visible
    clearUserSelection();

    // Jump to the last inserted card (or the first if only one)
    currentIndex = corrections.length - 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Card generation failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleRegenerateCard(hint = '', replaceCurrent = true) {
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') return;

  const chosen = window.WRITING_RULES[ruleSelect.value] || window.WRITING_RULES['flashcards_base'];
  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Re‑generating…';

    const model = getModelForType('flashcard'); // your existing model picker
    const prompt = generateRegenerateCardPrompt(card, hint, chosen); // from earlier step
    const results = await callLLMAPI(prompt, model); // or callGeminiAPI

    // Prefer first candidate if an array; accept object otherwise
    const r = Array.isArray(results) ? results[0] : results;
    if (!r || !r.front || !r.back) {
      alert('No usable alternative returned.');
      return;
    }

    const newCard = {
      type: 'flashcard',
      source: typeof r.source === 'string' && r.source.length ? r.source : (card.source || ''),
      front:  r.front,
      back:   r.back,
      explanation: typeof r.explanation === 'string' ? r.explanation : 'Regenerated variant.',
      position: { ...card.position }
    };

    // --- UNDO: save previous card to restore on undo ---
    undoStack.push({
      action: 'regenerate_replace',
      index: currentIndex,
      previous: { ...card }
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    // Replace the current card in place
    corrections[currentIndex] = newCard;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Re‑generate failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleSplitCard(userHint = '', useModal = false) {
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') return;

  const chosen = window.WRITING_RULES[ruleSelect.value] || window.WRITING_RULES['flashcards_base'];

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Splitting into two…';

    const model = getModelForType('flashcard');
    const prompt = generateSplitCardPrompt(card, chosen);
    let results = await callLLMAPI(prompt, model);

    // Fallback (manual) if the model doesn't return exactly two objects
    if (!Array.isArray(results) || results.length !== 2) {
      const sep = promptUserForSeparator(); // crude fallback
      if (!sep) { loadingOverlay.style.display = 'none'; return; }
      const parts = (card.back || '').split(sep).map(s => s.trim()).filter(Boolean);
      const two = parts.slice(0, 2);
      results = two.map((p, i) => ({
        source: card.source || '',
        front:  i === 0 ? card.front : `${card.front} (part 2)`,
        back:   p,
        explanation: 'Manual split by separator'
      }));
      if (results.length !== 2) {
        alert('Could not split into exactly two cards.');
        return;
      }
    }

    const normalized = results.map(obj => ({
      type: 'flashcard',
      source: (typeof obj.source === 'string' && obj.source.length) ? obj.source : (card.source || ''),
      front:  (typeof obj.front  === 'string') ? obj.front  : '',
      back:   (typeof obj.back   === 'string') ? obj.back   : '',
      explanation: (typeof obj.explanation === 'string') ? obj.explanation : 'Split from combined card.',
      position: { ...card.position }
    }));

    // --- UNDO: record split replacement ---
    undoStack.push({
      action: 'split_replace',
      index: currentIndex,
      previous: { ...card },
      newCards: normalized.map(x => ({ ...x }))
    });
    undoBtn.style.display = 'flex';
    redoStack.length = 0; if (redoBtn) redoBtn.style.display = 'none';

    // Replace current with first, insert second after
    corrections[currentIndex] = normalized[0];
    corrections.splice(currentIndex + 1, 0, normalized[1]);

    updateActiveCorrection();
  } catch (err) {
    console.error(err);
    alert('Split failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleReverseCard(userHint = '', useModal = false) {
  // We assume your "current card" is the active suggestion in corrections[currentIndex]
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') {
    alert('No flashcard selected to reverse.');
    return;
  }

  const chosen = window.WRITING_RULES[ruleSelect.value] || window.WRITING_RULES['flashcards_base'] || {};
  const model  = getModelForType('flashcard'); // if you haven’t added flashcard model mapping yet, pick one explicitly

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Reversing…';

    // 1) First attempt from the LLM
    const prompt1 = generateReverseCardPrompt(card, chosen, userHint);
    let result = await callLLMAPI(prompt1, model);

    // If provider returns arrays accidentally, prefer first object
    if (Array.isArray(result)) result = result[0];

    // 2) Validate; if meta or missing, retry once with stronger hint
    if (!result || !result.front || !result.back || looksMetaQuestion(result.front)) {
      const prompt2 = generateReverseCardPrompt(
        card,
        chosen,
        (userHint ? `${userHint}; ` : '') +
        'DO NOT write about "questions" or "answers"; use the pattern “X and Y are examples of what?” when applicable.'
      );
      let second = await callLLMAPI(prompt2, model);
      if (Array.isArray(second)) second = second[0];

      if (second && second.front && second.back && !looksMetaQuestion(second.front)) {
        result = second;
      } else {
        // 3) Heuristic fallback
        result = tryHeuristicReverse(card);
      }
    }

    if (!result || !result.front || !result.back) {
      alert('Reverse failed to produce a useful card.');
      return;
    }

    // Normalize → insert as a NEW suggestion right after the current one (so you can accept/reject)
    const reversed = {
      type: 'flashcard',
      source: (typeof result.source === 'string' && result.source.length) ? result.source : (card.source || ''),
      front:  (typeof result.front  === 'string') ? result.front  : '',
      back:   (typeof result.back   === 'string') ? result.back   : '',
      explanation: (typeof result.explanation === 'string') ? result.explanation : 'Reversed card.',
      position: { ...card.position }
    };

    // --- UNDO payload for "insert candidates" (so you can undo/redo)
    undoStack.push({ action: 'insert_candidates', afterIndex: currentIndex, items: [reversed] });
    if (typeof redoStack !== 'undefined') {
      redoStack.length = 0;
      const redoBtn = document.getElementById('redoBtn');
      if (redoBtn) redoBtn.style.display = 'none';
    }
    if (undoBtn) undoBtn.style.display = 'flex';

    // Insert and focus the new candidate
    corrections.splice(currentIndex + 1, 0, reversed);
    currentIndex = currentIndex + 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Reverse failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleNewFromHighlight(hint = '') {
  const base = corrections[currentIndex];
  if (!base || base.type !== 'flashcard') {
    alert('No flashcard selected.');
    return;
  }

  const chosen = window.WRITING_RULES[ruleSelect.value] || window.WRITING_RULES['flashcards_base'] || {};
  const model  = getModelForType('flashcard');

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Creating new card…';

    const prompt = generateNewFromHighlightPrompt(base, hint, chosen);
    let result = await callLLMAPI(prompt, model);

    // Accept a single object or a single-element array
    if (Array.isArray(result)) result = result[0];
    if (!result || !result.front || !result.back) {
      alert('No usable card returned.');
      return;
    }

    const newCard = {
      type: 'flashcard',
      source: (typeof result.source === 'string' && result.source.length) ? result.source : (base.source || ''),
      front:  result.front,
      back:   result.back,
      explanation: (typeof result.explanation === 'string') ? result.explanation : 'New card from highlight.',
      position: { ...base.position }   // anchor to the same highlight
    };

    // Record undo as an insertion of candidates after current
    undoStack.push({ action: 'insert_candidates', afterIndex: currentIndex, items: [newCard] });
    undoBtn.style.display = 'flex';
    if (redoStack) { redoStack.length = 0; if (redoBtn) redoBtn.style.display = 'none'; }

    // Insert after current, and focus the new one
    corrections.splice(currentIndex + 1, 0, newCard);
    currentIndex = currentIndex + 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('New-from-highlight failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}


function promptUserForSeparator() {
  const s = window.prompt('Model did not return two cards.\nEnter a separator to split the back into two (e.g., ";", "and", " / ").\nLeave blank to cancel.');
  return s && s.trim() ? s.trim() : null;
}

window.WRITING_RULES = {
  // Basic grammar and spelling check
  "grammar": {
    name: "Grammar & Spelling",
    description: "Check for grammatical errors and spelling mistakes",
    type: "grammar"
  },

   // NEW: Flashcards rule
  "flashcards": {
    name: "Flashcards",
    description: "Generate Q/A cards anchored to the source text",
    type: "flashcard"
  },

  "models_ultimateai": {
  // Set your preferred UltimateAI models here (user can override via modal input)
  "grammar":   "gpt-5",
  "style":     "gpt-5",
  "simplify":  "gpt-5",
  "proof":     "claude-4-opus",
  "flashcard": "gpt-5" // consider changing to claude-4-opus	
  },

  // Model specifications for different operations
  "models": {
    "grammar": "gemini-2.5-flash-preview-05-20",
    "style": "gemini-2.5-flash-preview-05-20", 
    "simplify": "gemini-2.5-pro-preview-06-05",
    "proof": "gemini-2.5-pro-preview-06-05",
    "flashcard": "gemini-2.5-pro-preview-06-05"          // NEW
  },
  "models_free": {
    "grammar": "gemini-2.5-flash-preview-05-20",
    "style": "gemini-2.5-flash-preview-05-20", 
    "simplify": "gemini-2.5-flash-preview-05-20",
    "proof": "gemini-2.5-flash-preview-05-20",
    "flashcard": "gemini-2.5-flash-preview-05-20"         // NEW
  }
};

// Initial setup
document.addEventListener('DOMContentLoaded', async () => {
  // Check for API key
  checkApiKey();

  // Restore previous choice if set
  const savedProvider = localStorage.getItem('provider') || 'gemini';
  if (providerSelect) providerSelect.value = savedProvider;
  toggleProviderFields(savedProvider);

  if (ultimateModelInput) {
    ultimateModelInput.value = localStorage.getItem('ultimateModel') || '';
  }

  // Export prefs defaults and load
  if (exportStyleSelect) {
    exportStyleSelect.value = localStorage.getItem('exportStyle') || 'neuracache';
    exportStyleSelect.addEventListener('change', () => {
      localStorage.setItem('exportStyle', exportStyleSelect.value);
      updateFlashcardsOutput();
    });
  }
  if (includeSourceCheckbox) {
    includeSourceCheckbox.checked = JSON.parse(localStorage.getItem('exportIncludeSource') || 'false');
    includeSourceCheckbox.addEventListener('change', () => {
      localStorage.setItem('exportIncludeSource', includeSourceCheckbox.checked);
      updateFlashcardsOutput();
    });
  }
  
  loadRules();

  freeModelsCheckbox.checked = JSON.parse(localStorage.getItem('useFreeModels') || 'false');
  languageSelect.value       = localStorage.getItem('languagePref') || 'en-US';
  styleSelect.value          = localStorage.getItem('stylePref')    || 'literary_nonfiction';
  
  depthSelect.value = localStorage.getItem('flashcardDepth') || 'medium';
  depthSelect.addEventListener('change', () =>
    localStorage.setItem('flashcardDepth', depthSelect.value)
  );

  freeModelsCheckbox.addEventListener('change', () =>
    localStorage.setItem('useFreeModels', freeModelsCheckbox.checked)
  );
  languageSelect.addEventListener('change', () =>
    localStorage.setItem('languagePref', languageSelect.value)
  );
  styleSelect.addEventListener('change', () =>
    localStorage.setItem('stylePref', styleSelect.value)
  );
  
  documentInput.value = `\\documentclass{article}
\\begin{document}

\\title{Sample Text: Load Your Own by Pasting Here or Use New Text Above}
\\author{John Smith}
\\maketitle

\\section{Introduction}
This paper presents an comprehensive overview of recent advancements in natural language processing. We will discuss the various aproaches that has been developed in the past decade.

The field have grown exponentially, with new models being released on a regular bases. Its important to understand these developments for anyone working in the field.

\\section{Methodology}
In this study, we examined 50 different papers published between 2020-2023. The data shows that transformer-based models is dominating the landscape.

We conducted extensive experiments to validate our hypothesis. Each experiment were carefully designed to test specific aspects of model performance.

\\section{Theorem}
\\textbf{Theorem 1:} For any language model $L$ with vocabulary size $V$ and embedding dimension $d$, the computational complexity of self-attention is $O(n^2 \\cdot d)$ where $n$ is the sequence length.

\\textbf{Proof:} Let us consider the attention mechanism. For each token in the sequence, we compute attention scores with all other tokens. This requires $n$ dot products for each of the $n$ tokens. Since each dot product operates on $d$-dimensional vectors, the total complexity is $n \\times n \\times d = O(n^2 \\cdot d)$. However, this assumes that the model processes all tokens simultaneously, which may not be true for all architectures.

\\section{Conclusion}
In conclusion, this study have shown that the landscape of NLP is rapidly evolving. Future work should focus on developing more efficent models.

\\end{document}`;
  
  adjustTextareaHeight();
  updateHighlightOverlay();

  // Sync scroll
  documentInput.addEventListener('scroll', () => {
    highlightOverlay.scrollTop = documentInput.scrollTop;
    highlightOverlay.scrollLeft = documentInput.scrollLeft;
  });

  documentInput.addEventListener('input', () => {
      // If user types, clear corrections
      if (corrections.length > 0) {
          resetState();
      }
      updateHighlightOverlay();
    // Auto-size only when overlay is off
      if (!(corrections.length > 0) && !selectionMode) {
        adjustTextareaHeight();
      } 
  });
  
  // Handle text selection
  documentInput.addEventListener('mouseup', handleTextSelection);
  documentInput.addEventListener('keyup', handleTextSelection);
    updateNavigation();
});

// Event Listeners
prevBtn.addEventListener('click', () => navigateCorrections(-1));
nextBtn.addEventListener('click', () => navigateCorrections(1));
popoverAcceptBtn.addEventListener('click', () => acceptCorrection(currentIndex));
popoverRejectBtn.addEventListener('click', () => rejectCorrection(currentIndex));
simplificationModalClose.addEventListener('click', closeSimplificationModal);
simplificationOverlay.addEventListener('click', closeSimplificationModal);
summaryClose.addEventListener('click', closeSummaryModal);
modalOverlay.addEventListener('click', closeSummaryModal);
apiKeySubmit.addEventListener('click', saveApiKey);
aboutClose.addEventListener('click', closeAboutModal);
aboutOverlay.addEventListener('click', closeAboutModal);
fileClose.addEventListener('click', closeFileModal);
fileOverlay.addEventListener('click', closeFileModal);
fileSelectBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', handleFileSelect);
simplifyBtn.addEventListener('click', handleSimplification);
proofBtn.addEventListener('click', handleProofCheck);
copyBtn.addEventListener('click', () => {
  // This line grabs the ENTIRE text from the editor, regardless of selection
  navigator.clipboard.writeText(documentInput.value).then(() => {
    const copyIcon = copyBtn.querySelector('.icon-copy');
    const checkIcon = copyBtn.querySelector('.icon-check');

    // Swap icons for feedback
    copyIcon.style.display = 'none';
    checkIcon.style.display = 'inline-block';

    // Swap back after 2 seconds
    setTimeout(() => {
      copyIcon.style.display = 'inline-block';
      checkIcon.style.display = 'none';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy text: ', err);
    alert('Failed to copy text.');
  });
});

// This listener is for the "Download" icon button
downloadBtn.addEventListener('click', () => {
  // This line also grabs the ENTIRE text from the editor
  const text = documentInput.value;
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'document.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Drag and drop handlers
dropZone.addEventListener('dragover', handleDragOver);
dropZone.addEventListener('dragleave', handleDragLeave);
dropZone.addEventListener('drop', handleDrop);

document.addEventListener('keydown', (e) => {
  // If any modal open, ignore global shortcuts
  const anyModalOpen =
    (actionModal && actionModal.classList.contains('visible')) ||
    (simplificationModal && simplificationModal.classList.contains('visible')) ||
    (summaryModal && summaryModal.classList.contains('visible')) ||
    (aboutModal && aboutModal.classList.contains('visible')) ||
    (fileModal && fileModal.classList.contains('visible')) ||
    (apiKeyModal && apiKeyModal.style.display === 'block');
  if (anyModalOpen) return;

  // Check if we're editing the corrected text
  if (document.activeElement === popoverCorrected || document.activeElement === popoverOriginal) {
    // Only allow normal typing, prevent our shortcuts
    if (['Enter', 'Backspace', 'Delete', 'Escape', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
      e.stopPropagation();
      if (e.key === 'Enter' || e.key === 'Escape') {
        e.preventDefault();
        popoverCorrected.blur(); // Exit editing
      }
    }
    return;
  }

  // Handle Undo (⌘/Ctrl + Z) for our action stack
  if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {
    if (undoStack.length > 0) {
      e.preventDefault();   // stop the textarea's native undo
      handleUndo();
      return;
    }
    // If no app-level undo, fall through to native behavior
  }

  // Redo (Cmd/Ctrl+Shift+Z)
  if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'z') {
    if (redoStack.length > 0) {
      e.preventDefault();
      handleRedo();
      return;
    }
  }

  // Only when a suggestion is active
  if (corrections.length > 0 && currentIndex > -1) {
    const k = e.key.toLowerCase();

    // Prevent browser Save dialog when we want Split modal
    if ((e.ctrlKey || e.metaKey) && k === 's') {
      e.preventDefault();
      openActionModal('split');
      return;
    }

    // Split (s)
    if (!e.ctrlKey && !e.metaKey && k === 's') {
      e.preventDefault();
      handleSplitCard('');
      return;
    }

    // Reverse (r) — Ctrl/⌘ for modal
    if ((e.ctrlKey || e.metaKey) && k === 'r') {
      e.preventDefault();
      openActionModal('reverse');
      return;
    }
    if (!e.ctrlKey && !e.metaKey && k === 'r') {
      e.preventDefault();
      handleReverseCard('');
      return;
    }

    // Regenerate (a) always opens modal
    if (!e.ctrlKey && !e.metaKey && k === 'a') {
      e.preventDefault();
      openActionModal('regenerate');
      return;
    }

    // New-from-highlight (n) — always opens modal; avoid Ctrl/⌘+N (browser new window)
    if (!e.ctrlKey && !e.metaKey && k === 'n') {
      e.preventDefault();
      openActionModal('new_from_highlight');
      return;
    }
  }

  if (e.key === 'ArrowRight') {
    e.preventDefault();
    nextBtn.click();
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    prevBtn.click();
  } else if (e.key === 'Enter') {
     e.preventDefault();
     acceptCorrection(currentIndex);
  } else if (e.key === 'Backspace' || e.key === 'Delete') {
    if (corrections.length > 0) {        // only lock keys while corrections are active
        e.preventDefault();
      rejectCorrection(currentIndex);
    }
  } else if (e.key === 'Escape') {
      e.preventDefault();
      hidePopover();
      closeSimplificationModal();
      closeAboutModal();
      closeFileModal();
  }
});


document.addEventListener('click', (e) => {
    // GUARD CLAUSE: If we are in correction mode, do not allow
    // a "click away" to hide the popover. The popover must persist.
    if (corrections.length > 0) {
        return;
    }

    // This logic now only runs when NOT in correction mode.
    // It's for any other potential popovers or future features.
    // We'll also simplify it slightly as its main job was for corrections.
    if (currentIndex > -1 && !suggestionPopover.contains(e.target) && !e.target.closest('.suggestion')) {
        hidePopover();
        // Resetting index here is important for when the user clicks away
        // from a suggestion instead of using the nav buttons.
        currentIndex = -1; 
        updateNavigation();
    }
});

function checkApiKey() {
  const provider = localStorage.getItem('provider') || 'gemini';
  const hasGemini = typeof window.GEMINI !== 'undefined' && !!window.GEMINI;
  const storedGemini = localStorage.getItem('geminiKey') || '';
  const storedUltimate = localStorage.getItem('ultimateKey') || '';

  // Fill fields if present
  if (providerSelect) providerSelect.value = provider;
  toggleProviderFields(provider);

  if (provider === 'gemini') {
    if (!hasGemini && !storedGemini) {
      apiKeyModal.style.display = 'block';
      loadingOverlay.style.display = 'flex';
      loadingOverlay.style.background = 'rgba(0, 0, 0, 0.5)';
      loadingText.style.display = 'none';
    }
  } else {
    if (!storedUltimate) {
      apiKeyModal.style.display = 'block';
      loadingOverlay.style.display = 'flex';
      loadingOverlay.style.background = 'rgba(0, 0, 0, 0.5)';
      loadingText.style.display = 'none';
    }
  }
}

function saveApiKey() {
  const provider = providerSelect ? providerSelect.value : 'gemini';
  localStorage.setItem('provider', provider);

  if (provider === 'gemini') {
    const key = apiKeyInput.value.trim();
    if (key) {
      window.GEMINI = key;
      localStorage.setItem('geminiKey', key);
    }
  } else {
    const uKey = ultimateKeyInput.value.trim();
    const uModel = ultimateModelInput.value.trim();
    if (uKey) localStorage.setItem('ultimateKey', uKey);
    if (uModel) localStorage.setItem('ultimateModel', uModel);
  }

  apiKeyModal.style.display = 'none';
  loadingOverlay.style.display = 'none';
  loadingOverlay.style.background = 'rgba(255, 255, 248, 0.9)';
  loadingText.style.display = 'block';
}

  function loadRules() {
    const selectors = [ ruleSelect, styleSelect ];
    
    selectors.forEach(selector => {
      if (!selector) return;
      selector.innerHTML = '';
      
      const isStyle = selector.id === 'styleSelect';
      
      Object.entries(window.WRITING_RULES)
        .filter(([key, rule]) => {
          if (!rule.name) return false;           // must have a name
          if (isStyle) {
            // Show only flashcard-type entries in the domain dropdown
            return typeof rule.prompt === 'string' && rule.type === 'flashcard';
          } else {
            // in the main rules dropdown, skip any model‐config keys
            return key !== 'models' && key !== 'models_free';
          }
        })
        .forEach(([key, rule]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = rule.name;
          selector.appendChild(option);
        });
    });
    
    // pick the first style rule as the default
    const firstStyle = Object.entries(window.WRITING_RULES)
      .find(([_k, r]) => typeof r.prompt === 'string');
    if (firstStyle) {
      styleSelect.value = firstStyle[0];
    }
  }

function resetState() {
    corrections = [];
    currentIndex = -1;
    documentInput.readOnly = false;
    undoStack = [];
    undoBtn.style.display = 'none';
    documentInput.classList.remove('locked'); // <-- UNLOCK MOUSE EVENTS
    hidePopover();
    updateHighlightOverlay();
    updateNavigation();
}

function handleTextSelection() {
    const hasSelection = documentInput.selectionStart !== documentInput.selectionEnd;
  
    if (hasSelection) {
        selectionMode = true;
        selectedText = documentInput.value.substring(documentInput.selectionStart, documentInput.selectionEnd);
        selectedRange = {
            start: documentInput.selectionStart,
            end: documentInput.selectionEnd
        };
    } else {
        selectionMode = false;
        selectedText = '';
        selectedRange = null;
    }
  
    updateHighlightOverlay();
    updateNavigation(); 
}

function clearUserSelection() {
    // 1. Collapse the logical selection in the textarea
    documentInput.setSelectionRange(documentInput.selectionStart, documentInput.selectionStart);

    // 2. Reset our application's selection state variables
    selectionMode = false;
    selectedText = '';
    selectedRange = null;

    // 3. Force the UI to update based on the now-cleared state
    updateHighlightOverlay();
    updateNavigation();
}

function getLanguageInstruction() {
    const languageSelect = document.getElementById('languageSelect');
    const selectedOption = languageSelect.options[languageSelect.selectedIndex];
    const languageValue = selectedOption.value;
    const languageText = selectedOption.text;

    if (languageValue === 'other') {
        return '';
    }
    return `The primary language of this document is ${languageText}.\n\n`;
}

function getModelForType(type) {
  const provider = localStorage.getItem('provider') || 'gemini';
  if (provider === 'ultimateai') {
    // If user typed a specific UltimateAI model, prefer it for flashcards
    if (type === 'flashcard') {
      const userModel = localStorage.getItem('ultimateModel') || (ultimateModelInput ? ultimateModelInput.value.trim() : '');
      if (userModel) return userModel;
    }
    const m = (window.WRITING_RULES.models_ultimateai || {})[type];
    return m || 'gpt-4o-mini';
  }

  // Gemini path
  const useFreeModels = document.getElementById('freeModelsCheckbox').checked;
  const rulesRoot = window.WRITING_RULES || {};
  const models = useFreeModels ? rulesRoot.models_free : rulesRoot.models;
  return (models && models[type]) ? models[type] : 'gemini-2.0-flash';
}

function extractLatexContent(text) {
  // Check if it's a LaTeX document
  if (!text.includes('\\begin{document}')) {
    return text;
  }
  
  const beginMatch = text.indexOf('\\begin{document}');
  const endMatch = text.indexOf('\\end{document}');
  
  if (beginMatch !== -1 && endMatch !== -1) {
    // Extract content between \begin{document} and \end{document}
    return text.substring(beginMatch + '\\begin{document}'.length, endMatch).trim();
  } else if (beginMatch !== -1) {
    // Only \begin{document} found, take everything after it
    return text.substring(beginMatch + '\\begin{document}'.length).trim();
  }
  
  return text;
}

function handleUndo() {
  if (undoStack.length === 0) return;
  const last = undoStack.pop();

  // Card accepts (remove from bin; restore suggestion)
  if (last.action === 'accept_card') {
    const { index, correction, card } = last;
    const i = acceptedFlashcards.findIndex(c => c.front === card.front && c.back === card.back);
    if (i !== -1) acceptedFlashcards.splice(i, 1);
    updateFlashcardsOutput();
    corrections.splice(index, 0, correction);
    currentIndex = index;

    // Push redo payload
    redoStack.push({ action: 'accept_card', index, correction, card });
    const redoBtn = document.getElementById('redoBtn');
    if (redoBtn) redoBtn.style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Card rejects (reinsert suggestion)
  if (last.action === 'reject_card') {
    const { index, correction } = last;
    corrections.splice(index, 0, correction);
    currentIndex = index;

    redoStack.push({ action: 'reject_card', index });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Regenerate replace (restore previous)
  if (last.action === 'regenerate_replace') {
    const { index, previous, nextCard } = last;
    corrections[index] = previous;
    currentIndex = index;

    redoStack.push({ action: 'regenerate_replace', index, previous, nextCard });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Insert candidates (split/reverse) — remove them
  if (last.action === 'insert_candidates') {
    const { afterIndex, items } = last;
    corrections.splice(afterIndex + 1, items.length);
    currentIndex = afterIndex;

    redoStack.push({ action: 'insert_candidates', afterIndex, items });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Split replace — restore original and remove the two new cards
  if (last.action === 'split_replace') {
    const { index, previous, newCards } = last;
    // Remove the two new cards and put the original back
    corrections.splice(index, 2, previous);
    currentIndex = index;

    // Redo payload: re-apply the split replacement
    redoStack.push({ action: 'split_replace', index, previous, newCards });
    const rb = document.getElementById('redoBtn'); if (rb) rb.style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Legacy text edit (grammar/style accept)
  documentInput.value = last.textBefore;
  corrections.splice(last.index, 0, last.correction);
  if (last.lengthDiff) {
    for (let i = last.index + 1; i < corrections.length; i++) {
      corrections[i].position.start -= last.lengthDiff;
      corrections[i].position.end   -= last.lengthDiff;
    }
  }
  currentIndex = last.index;

  // Prepare redo payload for legacy edit
  const editedText = popoverCorrected.textContent || '';
  redoStack.push({ action: 'legacy_text', index: last.index, correction: last.correction, editedText, _undoPayload: last });
  document.getElementById('redoBtn').style.display = 'flex';

  updateActiveCorrection();
  if (undoStack.length === 0) undoBtn.style.display = 'none';
}


function handleRedo() {
  if (redoStack.length === 0) return;
  const next = redoStack.pop();

  // Mirror the forward actions you support.
  if (next.action === 'accept_card') {
    // Apply accept again
    const { index, correction, card } = next;
    // Remove the suggestion at index (if it exists at index; else find it)
    const idx = (index >= 0 && index < corrections.length && corrections[index] === correction)
      ? index
      : corrections.findIndex(c => c === correction);
    if (idx !== -1) {
      acceptedFlashcards.push({ front: card.front, back: card.back });
      updateFlashcardsOutput();
      corrections.splice(idx, 1);
      currentIndex = Math.min(idx, corrections.length - 1);
      undoStack.push({ action: 'accept_card', correction, index: idx, card, textBefore: documentInput.value });
      undoBtn.style.display = 'flex';
    }
  } else if (next.action === 'reject_card') {
    // Re-apply reject (remove suggestion again)
    const { index } = next;
    if (index >= 0 && index < corrections.length) {
      const removed = corrections.splice(index, 1)[0];
      undoStack.push({ action: 'reject_card', correction: removed, index, textBefore: documentInput.value });
      undoBtn.style.display = 'flex';
      currentIndex = Math.min(index, corrections.length - 1);
    }
  } else if (next.action === 'regenerate_replace') {
    // Re-apply replacement (use 'next' card)
    const { index, previous, nextCard } = next;
    const prev = corrections[index];
    corrections[index] = nextCard;
    undoStack.push({ action: 'regenerate_replace', index, previous: prev, nextCard });
    undoBtn.style.display = 'flex';
    currentIndex = index;
  } else if (next.action === 'insert_candidates') {
    // Reinsert newly created suggestions (split/reverse)
    const { afterIndex, items } = next;
    corrections.splice(afterIndex + 1, 0, ...items);
    undoStack.push({ action: 'insert_candidates', afterIndex, items });
    undoBtn.style.display = 'flex';
    currentIndex = afterIndex + 1;
  } else if (next.action === 'split_replace') {
    const { index, previous, newCards } = next;
    const prevAtIndex = corrections[index];
    // Apply split again
    corrections.splice(index, 1, newCards[0]);
    corrections.splice(index + 1, 0, newCards[1]);

    undoStack.push({ action: 'split_replace', index, previous: prevAtIndex, newCards });
    undoBtn.style.display = 'flex';
    currentIndex = index;
   } else {
    // Legacy text edit redo (grammar/style)
    const { index, correction, editedText } = next;
    let currentText = documentInput.value;
    const len = correction.position.end - correction.position.start;
    documentInput.value = currentText.substring(0, correction.position.start) + editedText +
                          currentText.substring(correction.position.start + len);
    undoStack.push(next._undoPayload); // symmetric payload saved when pushing redo
    undoBtn.style.display = 'flex';
    currentIndex = Math.min(index, corrections.length - 1);
  }

  if (redoStack.length === 0) {
    const redoBtn = document.getElementById('redoBtn');
    if (redoBtn) redoBtn.style.display = 'none';
  }
  updateActiveCorrection();
}

function splitTextIntoChunks(text, maxChunkSize = 30000) {
  const chunks = [];
  const paragraphs = text.split(/\n\n+/);
  let currentChunk = '';
  
  for (const paragraph of paragraphs) {
    if (currentChunk.length + paragraph.length + 2 > maxChunkSize && currentChunk.length > 0) {
      chunks.push(currentChunk.trim());
      currentChunk = paragraph;
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }
  
  console.log(`Split text into ${chunks.length} chunks. Sizes:`, chunks.map(c => c.length));
  
  return chunks;
}

function generatePrompt(text, rule) {
 if (rule.type === 'flashcard') {
    const languageInstruction = getLanguageInstruction();
    const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
    const depthInstruction = {
      shallow: `Generate only high-yield cards. Target ~1 card per 300–500 words (or 3–5 paragraphs).`,
      medium:  `Generate 1–3 cards per paragraph (~1 per 150–250 words).`,
      complete:`Generate cards for nearly every line of content: each definition, equation, step, bullet, and claim gets at least one card. If sentences contain multiple ideas, create multiple cards.`
    }[depth] || '';

    // rule.prompt is our DOMAIN fragment from styles.js
    const domainFragment = (rule.prompt || '');

    const currentDate = new Date();
    return `${languageInstruction}You are an expert study coach on ${currentDate}.
    Read the DOCUMENT and output ONLY a JSON array of flashcard objects in order of appearance.
    Atomicity: each "back" expresses exactly one idea.
    Univocality: each "front" has a single correct answer.
    Anchoring: include a "source" snippet (<=160 chars) copied verbatim from the document that motivates the card.
    Notation: you may use Markdown and LaTeX (inline $...$ or display \\[ ... \\]); preserve original symbols/notation. Do not wrap answers in triple backticks.
    No meta commentary. No markdown outside of the Q/A text itself.

    ${depthInstruction}

    Domain guidance:
    ${domainFragment}

    JSON schema (strict):
    [
      {
        "source": "verbatim snippet from the document (<=160 chars, must exist in the text)",
        "front": "short question/prompt; single-answered",
        "back": "concise but complete answer; one idea; may include LaTeX",
        "explanation": "optional: why this card matters (short)"
      },
      ...
    ]

    DOCUMENT:
    \`\`\`
    ${text}
    \`\`\`
    `;
      }
  if (rule.type === 'grammar') {
    console.log(`Grammar`);
    const languageInstruction = getLanguageInstruction();
    const currentDate = new Date();
    return `${languageInstruction}You are an elite editor on ${currentDate}. Analyze the following document for grammatical errors, typos, and spelling mistakes. Return ONLY a JSON array of correction objects. Important: Return the list of corrections in the order they appear in the document. DOUBLE CHECK THAT SUGGESTIONS YOU MAKE ACTUALLY REQUIRE A CORRECTION - NEVER SUGGEST 'No change needed' OR SIMILAR!

Each object must have these exact keys:
- "original": The exact text snippet from the document to be replaced. Be specific enough to be unique.
- "corrected": The corrected version of the text.
- "explanation": A brief, clear reason for the change (e.g., "Grammar: Subject-verb agreement.").
- "type": Must be "grammar".

Focus only on clear errors which are unambiguous. DO NOT suggest em dashes or other changes to hyphenation or dash offsets. Follow University of Chicago style guidelines. Do not suggest stylistic changes; the user has a style editor who handles those corrections. Do not suggest changes for LaTeX commands (like \\documentclass), including opening or closing brackets, and do not correct single vs. double spaces.  Note that the text may be latex, so Latex-style quotation marks (double accent grave, or double apostrophe), or slash before dollar signs or percentages, are not errors. IMPORTANT: The output MUST be a valid JSON array. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).
Return an empty array [] if no errors are found.  

Document to analyze:
\`\`\`
${text}
\`\`\`
`;
  } else {
    console.log(`Style: ${rule.prompt}`);
    const languageInstruction = getLanguageInstruction();
    const currentDate = new Date();
    return `${rule.prompt} ${languageInstruction} It is ${currentDate}.

Return ONLY a JSON array of style suggestion objects. Important: Return the list of corrections in the order they appear in the document. Each object must have these exact keys:
- "original": The exact text snippet from the document to be replaced. THIS SHOULD BE EXACT. We may use LaTeX slash breaks for $ or %, and use extra \\ to avoid escapes.
- "corrected": The improved version of the text.
- "explanation": A brief, clear reason for the change.
- "type": Must be "style".

Do not check grammar or spelling. Do not suggest changes for LaTeX commands. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).
Return an empty array [] if no improvements are needed.

Document to analyze:
\`\`\`
${text}
\`\`\`
`;
  }
}


function generateSimplificationPrompt(text, context) {
  const languageInstruction = getLanguageInstruction();
  const currentDate = new Date();
  const model = getModelForType('simplify');
  return `${languageInstruction}You are an elite editor on ${currentDate}. The following text may come from an academic article (in which case act like an editor for academically precise content where you still care about good, easy-to-read writing), or general writing. Simplify the following text passage. Provide exactly THREE versions:

1. Same Length: Use simpler words and shorter sentences, but keep approximately the same length. Do NOT replace technical terms if they have precise definitions, but do make the writing snappier and less unwieldy, like a great editor would.
2. Moderately Shorter: Do the same as in step 1, but reduce length by about 30% while maintaining all key information
3. Much Shorter: Do the same as in step 2, but reduce length by 50-60%, keeping only essential information

IMPORTANT: Never change mathematical notation, technical terminology, formulas, or proper nouns. Only simplify the language structure and non-technical vocabulary. Do not use markdown in your response. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).

Return as JSON:
{
  "same_length": "simplified text here",
  "moderate": "shorter simplified text here",
  "concise": "much shorter text here"
}

Text to simplify:
"${text}"

Context (for reference only):
${context}
`;
}

function generateProofCheckPrompt(proofText, fullDocument) {
  const languageInstruction = getLanguageInstruction();
  const currentDate = new Date();
  const model = getModelForType('proof');
  return `${languageInstruction}Act like a very well-trained technical graduate student on ${currentDate}. Check the validity of the following mathematical proof or logical argument. Analyze it for:
- Logical errors or gaps in reasoning
- Missing steps or assumptions
- Incorrect applications of theorems or definitions
- Unclear or ambiguous statements
Be sure to go through the precise assumptions, the precise conclusions, and the logical steps between them, checking every step for accuracy. If you believe there is an error or omission, be as precise as possible, and write all mathematics in LaTeX. Do not use markdown as a bold. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).

Return a JSON object:
{
  "is_valid": true/false,
  "issues": ["List of specific problems found"],
  "questions": ["List of clarifying questions about unclear parts"],
  "suggestions": ["List of specific improvements"],
  "overall": "Brief overall assessment"
}

Proof to check:
"${proofText}"

Full document context:
${fullDocument}
`;
}

function toggleProviderFields(provider) {
  if (!geminiFields || !ultimateFields) return;
  if (provider === 'ultimateai') {
    geminiFields.style.display = 'none';
    ultimateFields.style.display = 'block';
    // The "Use free models" toggle is Gemini-specific; hide if not Gemini
    const freeBox = document.getElementById('freeModelsCheckbox');
    if (freeBox) freeBox.parentElement.style.display = 'none';
  } else {
    geminiFields.style.display = 'block';
    ultimateFields.style.display = 'none';
    const freeBox = document.getElementById('freeModelsCheckbox');
    if (freeBox) freeBox.parentElement.style.display = 'flex';
  }
}
if (providerSelect) {
  providerSelect.addEventListener('change', () => {
    localStorage.setItem('provider', providerSelect.value);
    toggleProviderFields(providerSelect.value);
  });
}

function openActionModal(kind, preset='') {
  pendingAction = kind;
  actionTitle.textContent = kind === 'split' ? 'Split Card (Optional Hint)'
                        : kind === 'reverse' ? 'Reverse Card (Optional Hint)'
                        : 'Regenerate Card';
  actionHintArea.value = preset || '';
  actionModal.classList.add('visible');
  actionOverlay.classList.add('visible');
  setTimeout(() => actionHintArea.focus(), 0);
}
function closeActionModal() {
  pendingAction = null;
  actionModal.classList.remove('visible');
  actionOverlay.classList.remove('visible');
}

if (actionClose)   actionClose.addEventListener('click', closeActionModal);
if (actionCancel)  actionCancel.addEventListener('click', closeActionModal);
if (actionOverlay) actionOverlay.addEventListener('click', closeActionModal);

// Submit
if (actionSubmit) actionSubmit.addEventListener('click', () => {
  const hint = (actionHintArea.value || '').trim();
  if (pendingAction === 'regenerate') handleRegenerateCard(hint, /*replaceCurrent=*/true);
  if (pendingAction === 'split')      handleSplitCard(hint, /*useModal=*/true);
  if (pendingAction === 'reverse')    handleReverseCard(hint, /*useModal=*/true);
  if (pendingAction === 'new_from_highlight') handleNewFromHighlight((actionHintArea.value || '').trim());
  closeActionModal();
});

// Buttons (Ctrl/⌘ opens modal; normal click immediate)
if (splitBtn) splitBtn.addEventListener('click', (e) => {
  (e.ctrlKey || e.metaKey) ? openActionModal('split') : handleSplitCard('');
});
if (reverseBtn) reverseBtn.addEventListener('click', (e) => {
  (e.ctrlKey || e.metaKey) ? openActionModal('reverse') : handleReverseCard('');
});
if (regenBtn) regenBtn.addEventListener('click', () => openActionModal('regenerate'));
if (newFromHighlightBtn) newFromHighlightBtn.addEventListener('click', () => openActionModal('new_from_highlight'));

// Temporary alias until provider switch lands
// async function callLLMAPI(prompt, model, retryCount = 0) {
//  return callGeminiAPI(prompt, model, retryCount);
// }

async function callLLMAPI(prompt, model, retryCount = 0) {
  const provider = localStorage.getItem('provider') || 'gemini';

  if (provider === 'ultimateai') {
    // --- UltimateAI (OpenAI-style chat completions) ---
    const key = localStorage.getItem('ultimateKey') || (ultimateKeyInput ? ultimateKeyInput.value.trim() : '');
    if (!key) throw new Error('UltimateAI key missing.');

    const API_URL = 'https://smart.ultimateai.org/v1/chat/completions';
    const payload = {
      model: model,
      messages: [
        { role: 'system', content: 'You are a precise assistant. Return ONLY valid JSON.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.2
      // Avoid response_format forcing objects because we often want arrays
    };

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err.error?.message || `UltimateAI API error ${response.status}`);
      }
      const data = await response.json();
      const content = data?.choices?.[0]?.message?.content;
      if (!content) throw new Error('UltimateAI response missing content.');
      const parsed = parseJSONLoose(content);
      if (parsed !== null) return parsed;
      throw new Error('Failed to parse any valid JSON from the UltimateAI response.');
    } catch (e) {
      if (retryCount === 0) {
        console.log('UltimateAI error, retrying once…', e.message);
        await new Promise(r => setTimeout(r, 2000));
        return callLLMAPI(prompt, model, 1);
      }
      throw e;
    }
  }

  // --- Gemini path (unchanged behavior) ---
  let gkey = window.GEMINI || localStorage.getItem('geminiKey') || '';
  if (!gkey) throw new Error('Gemini key missing.');

  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${gkey}`;
  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: { responseMimeType: 'application/json', temperature: 0.2 }
  };

  try {
    const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      if (response.status === 429 && retryCount === 0) {
        await new Promise(r => setTimeout(r, 30000)); // rate limit backoff
        return callLLMAPI(prompt, model, 1);
      }
      throw new Error(error.error?.message || `Gemini API error ${response.status}`);
    }
    const data = await response.json();
    const part = data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!part) throw new Error('Gemini response malformed.');
    const parsed = parseJSONLoose(part);
    if (parsed !== null) return parsed;
    throw new Error('Failed to parse any valid JSON from the Gemini response.');
  } catch (e) {
    if (retryCount === 0 && String(e.message || '').includes('fetch')) {
      await new Promise(r => setTimeout(r, 30000));
      return callLLMAPI(prompt, model, 1);
    }
    throw e;
  }
}

function parseJSONLoose(text) {
  if (!text || typeof text !== 'string') return null;

  // 1) Code fences
  const fence = text.match(/```json\s*([\s\S]*?)```/i) || text.match(/```\s*([\s\S]*?)```/);
  if (fence) {
    try { return JSON.parse(fence[1]); } catch {}
  }

  // 2) Direct parse
  try { return JSON.parse(text); } catch {}

  // 3) Bracket cropping: get biggest {...} or [...]
  const firstObj = text.indexOf('{');
  const lastObj  = text.lastIndexOf('}');
  const firstArr = text.indexOf('[');
  const lastArr  = text.lastIndexOf(']');

  const candidates = [];
  if (firstArr !== -1 && lastArr > firstArr) candidates.push(text.slice(firstArr, lastArr + 1));
  if (firstObj !== -1 && lastObj > firstObj) candidates.push(text.slice(firstObj, lastObj + 1));

  for (const c of candidates) {
    try { return JSON.parse(c); } catch {}
  }

  return null;
}

async function handleAnalysis() {
  clearUserSelection();
  const currentText = documentInput.value;
  if (!currentText.trim()) {
    alert('Please enter some text to analyze.');
    return;
  }
  
  const selectedRule = window.WRITING_RULES[ruleSelect.value];
  if (!selectedRule) {
    alert('Please select a rule.');
    return;
  }
  
  resetState();
  loadingOverlay.style.display = 'flex';
  
  try {
    // Extract LaTeX content if applicable
    const extractedText = extractLatexContent(currentText);
    
    // Split text into chunks
    const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
    const maxChunk = depth === 'complete' ? 12000 : 30000;   // tighter chunks for dense outputs
    const chunks = splitTextIntoChunks(extractedText, maxChunk);
    
    const model = getModelForType(selectedRule.type);
    loadingText.textContent = `Analyzing with ${selectedRule.name}...`;
    
    const allCorrections = [];

    // Process each chunk
    for (let i = 0; i < chunks.length; i++) {
      loadingText.textContent = `Analyzing part ${i + 1} of ${chunks.length}...`;
      
      const prompt = generatePrompt(chunks[i], selectedRule);
      const results = await callLLMAPI(prompt, model);
      
      if (Array.isArray(results)) {
        allCorrections.push(...results);
      }
    }

    // Map results to positions in the original document
    let searchFromIndex = 0;
    const mappedCorrections = [];
    const snippetKey = (selectedRule.type === 'flashcard') ? 'source' : 'original';

    for (const corr of allCorrections) {
      if (!corr || typeof corr[snippetKey] !== 'string' || corr[snippetKey].length === 0) {
        console.warn("Skipping invalid object from API:", corr);
        continue;
      }
      const foundAtIndex = currentText.indexOf(corr[snippetKey], searchFromIndex);
      if (foundAtIndex !== -1) {
        corr.position = { start: foundAtIndex, end: foundAtIndex + corr[snippetKey].length };
        if (selectedRule.type === 'flashcard') {
          corr.type = 'flashcard';
          corr.front = (typeof corr.front === 'string') ? corr.front : '';
          corr.back  = (typeof corr.back  === 'string') ? corr.back  : '';
          corr.explanation = (typeof corr.explanation === 'string') ? corr.explanation : '';
        }
        mappedCorrections.push(corr);
        searchFromIndex = corr.position.end;
      } else {
        console.warn(`Could not anchor object using "${corr[snippetKey]}"`);
      }
    }
    corrections = mappedCorrections;

    if (corrections.length > 0) {
      documentInput.readOnly = true;        // Prevent typing
      documentInput.classList.add('locked'); // <-- LOCK MOUSE EVENTS
      currentIndex = 0;
      updateActiveCorrection();
    } else {
        // No corrections found, so ensure it's not locked
        documentInput.readOnly = false;
        documentInput.classList.remove('locked');
        highlightOverlay.innerHTML = escapeHtml(currentText) + `<div class="empty-state"><h3>No suggestions found</h3><p>Your document looks great!</p></div>`;
    }

  } catch (error) {
    alert(`Analysis failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
    loadingText.textContent = 'Analyzing...';
  }
} 

async function handleSimplification() {
  if (!selectedText || !selectedRange) return;
  
  loadingOverlay.style.display = 'flex';
  loadingText.textContent = 'Generating simplifications...';
  
  try {
    const model = getModelForType('simplify');
    const fullText = documentInput.value;
    
    // Get context (1000 chars before and after)
    const contextStart = Math.max(0, selectedRange.start - 1000);
    const contextEnd = Math.min(fullText.length, selectedRange.end + 1000);
    const context = fullText.substring(contextStart, contextEnd);
    
    const prompt = generateSimplificationPrompt(selectedText, context);
    const result = await callLLMAPI(prompt, model);
    
    // Display simplification options in modal
    displaySimplifications(result);
    
  } catch (error) {
    alert(`Simplification failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleProofCheck() {
  if (!selectedText || !selectedRange) return;
  
  loadingOverlay.style.display = 'flex';
  loadingText.textContent = 'Checking proof validity...';
  
  try {
    const model = getModelForType('proof');
    const fullText = documentInput.value;
    
    const prompt = generateProofCheckPrompt(selectedText, fullText);
    const result = await callLLMAPI(prompt, model);
    
    // Display proof check results in summary modal
    displayProofCheck(result);
    
  } catch (error) {
    alert(`Proof check failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

function displayProofCheck(result) {
  let html = '';
  
  html += `<div class="summary-section">
    <h3>Validity</h3>
    <p><strong>${result.is_valid ? 'Valid' : 'Invalid or Incomplete'}</strong></p>
  </div>`;
  
  if (result.overall) {
    html += `<div class="summary-section">
      <h3>Overall Assessment</h3>
      <p>${escapeHtml(result.overall)}</p>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.issues && result.issues.length > 0) {
    html += `<div class="summary-section">
      <h3>Issues Found</h3>
      <ul>${result.issues.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.questions && result.questions.length > 0) {
    html += `<div class="summary-section">
      <h3>Clarifying Questions</h3>
      <ul>${result.questions.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.suggestions && result.suggestions.length > 0) {
    html += `<div class="summary-section">
      <h3>Suggestions</h3>
      <ul>${result.suggestions.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Update the summary modal title temporarily
  const modalTitle = summaryModal.querySelector('h2');
  const originalTitle = modalTitle.textContent;
  modalTitle.textContent = 'Proof Validity Check';
  
  summaryContent.innerHTML = html;
  summaryModal.classList.add('visible');
  modalOverlay.classList.add('visible');
  
  // Restore original title when modal closes
  const restoreTitle = () => {
    modalTitle.textContent = originalTitle;
    modalOverlay.removeEventListener('click', restoreTitle);
    summaryClose.removeEventListener('click', restoreTitle);
  };
  modalOverlay.addEventListener('click', restoreTitle);
  summaryClose.addEventListener('click', restoreTitle);
}

function displaySimplifications(options) {
  // Set original text
  simplificationOriginal.textContent = selectedText;
  
  let html = '';
  
  const variants = [
    { key: 'same_length', label: 'Same Length (Simpler Language)' },
    { key: 'moderate', label: 'Moderately Shorter (~30% reduction)' },
    { key: 'concise', label: 'Much Shorter (~50-60% reduction)' }
  ];
  
  variants.forEach(variant => {
    if (options[variant.key]) {
      html += `
        <div class="simplification-option" data-text="${options[variant.key].replace(/"/g, '&quot;')}">
          <div class="simplification-label">${variant.label}</div>
          <div class="simplification-text">${escapeHtml(options[variant.key])}</div>
        </div>
      `;
    }
  });
  
  simplificationOptions.innerHTML = html;
  
  // Add click handlers
  document.querySelectorAll('.simplification-option').forEach(option => {
    option.addEventListener('click', () => {
      const newText = option.getAttribute('data-text').replace(/&quot;/g, '"');
      replaceSelectedText(newText);
      closeSimplificationModal();
    });
  });
  
  // Show modal
  simplificationModal.classList.add('visible');
  simplificationOverlay.classList.add('visible');
}

function replaceSelectedText(newText) {
  if (!selectedRange) return;
  
  const currentText = documentInput.value;
  const before = currentText.substring(0, selectedRange.start);
  const after = currentText.substring(selectedRange.end);
  
  documentInput.value = before + newText + after;
  
  clearUserSelection();
}

function closeSimplificationModal() {
  simplificationModal.classList.remove('visible');
  simplificationOverlay.classList.remove('visible');
}

function closeSummaryModal() {
  summaryModal.classList.remove('visible');
  modalOverlay.classList.remove('visible');
}

function updateHighlightOverlay() {
  const currentText = documentInput.value;
  const needOverlay = (selectionMode && selectedRange) || (corrections.length > 0);

  if (!needOverlay) {
    // Overlay fully off
    highlightOverlay.innerHTML = '';
    highlightOverlay.style.display = 'none';
    document.getElementById('mainContent')?.classList.remove('overlay-active');

    // Let the textarea size to its content in normal mode
    documentInput.style.height = 'auto';
    adjustTextareaHeight();
    return;
  }

  // Overlay on
  highlightOverlay.style.display = 'block';
  document.getElementById('mainContent')?.classList.add('overlay-active');

  // --- GROUP corrections by anchor (kept from your current version) ---
  const groupsMap = new Map();
  corrections.forEach((c, i) => {
    if (!c.position) return;
    const key = `${c.position.start}:${c.position.end}`;
    if (!groupsMap.has(key)) groupsMap.set(key, { start: c.position.start, end: c.position.end, idxs: [] });
    groupsMap.get(key).idxs.push(i);
  });
  const groups = Array.from(groupsMap.values()).sort((a,b) => (a.start - b.start) || (a.end - b.end));

  let html = '';
  let lastPos = 0;

  // User selection first
  if (selectionMode && selectedRange) {
    html += escapeHtml(currentText.substring(0, selectedRange.start));
    html += `<mark class="user-selection">${escapeHtml(currentText.substring(selectedRange.start, selectedRange.end))}</mark>`;
    lastPos = selectedRange.end;
  }

  // Grouped suggestions
  for (const g of groups) {
    if (selectionMode && selectedRange && g.start < selectedRange.end && g.end > selectedRange.start) continue;
    html += escapeHtml(currentText.substring(lastPos, g.start));
    const originalText = currentText.substring(g.start, g.end);
    const firstIndex = g.idxs[0];
    const groupAttr = g.idxs.join(',');
    html += `<mark class="suggestion" data-index="${firstIndex}" data-group="${groupAttr}">${escapeHtml(originalText)}${
      g.idxs.length > 1 ? `<sup class="badge">×${g.idxs.length}</sup>` : ''
    }</mark>`;
    lastPos = g.end;
  }

  html += escapeHtml(currentText.substring(lastPos));
  highlightOverlay.innerHTML = html;

  // Match textarea height to overlay height while overlay is active
  documentInput.style.height = highlightOverlay.offsetHeight + 'px';

  // Click to cycle within group
  document.querySelectorAll('.suggestion').forEach(mark => {
    mark.addEventListener('click', (e) => {
      const group = (e.currentTarget.dataset.group || '')
        .split(',').map(n => parseInt(n,10)).filter(n => !isNaN(n));
      if (group.length <= 1) {
        currentIndex = parseInt(e.currentTarget.dataset.index, 10);
      } else {
        const pos = group.indexOf(currentIndex);
        const next = (pos === -1 || pos === group.length - 1) ? group[0] : group[pos + 1];
        currentIndex = next;
      }
      updateActiveCorrection();
    });
  });
}


function escapeHtml(text) {
  if (typeof text !== 'string') return '';
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function adjustTextareaHeight() {
  // Auto-size the textarea when overlay is not active
  documentInput.style.height = 'auto';
  documentInput.style.height = documentInput.scrollHeight + 'px';
}

// --- Reverse-card helpers ---
function looksMetaQuestion(s) {
  if (!s) return false;
  const t = s.toLowerCase();
  return /what question|which question|would give the answer|given the answer|answer would be/.test(t);
}

function tryHeuristicReverse(card) {
  // Patterns: "types of X", "examples of X"
  const front = (card.front || '').toLowerCase();
  const m1 = front.match(/types?\s+of\s+(.+?)[\.\?]*$/i);
  const m2 = front.match(/examples?\s+of\s+(.+?)[\.\?]*$/i);
  const concept = (m1 && m1[1]) || (m2 && m2[1]) || null;

  if (concept) {
    const examples = (card.back || '').replace(/\s+/g, ' ').trim();
    const frontRev = `${examples} are ${m2 ? 'examples' : 'types'} of what?`;
    return {
      source: card.source || '',
      front: frontRev,
      back: concept.trim(),
      explanation: 'Heuristic reverse from "types/examples of X".'
    };
  }
  // Fallback generic swap if nothing better
  return {
    source: card.source || '',
    front: (card.back || '').trim(),
    back: (card.front || '').trim(),
    explanation: 'Quick reverse (swap) due to unrecognized pattern.'
  };
}


function updateActiveCorrection() {
    if (currentIndex < 0 || currentIndex >= corrections.length) {
        hidePopover();
        return;
    }

    updateHighlightOverlay();
    requestAnimationFrame(() => {
       let activeMark = highlightOverlay.querySelector(`.suggestion[data-index="${currentIndex}"]`);
        if (!activeMark) {
          // Find any group that contains this index
          activeMark = Array.from(highlightOverlay.querySelectorAll('.suggestion'))
            .find(el => (el.dataset.group || '').split(',').includes(String(currentIndex)));
        }
       if (activeMark) {
           activeMark.classList.add('active');
           showPopoverFor(activeMark);
           activeMark.scrollIntoView({ behavior: 'smooth', block: 'center' });
       }
    });
    
    updateNavigation();
}

function showPopoverFor(element) {
  const correction = corrections[currentIndex];
  if (!correction) return;

  if (correction.type === 'flashcard') {
    popoverExplanation.textContent = correction.explanation || 'Edit the card (Front/Back) and press Enter to accept or Backspace/Delete to reject.';
    popoverOriginal.setAttribute('contenteditable', 'true');
    popoverCorrected.setAttribute('contenteditable', 'true');
    popoverOriginal.textContent = correction.front || '';
    popoverCorrected.textContent = correction.back || '';
  } else {
    popoverExplanation.textContent = correction.explanation || '';
    popoverOriginal.removeAttribute('contenteditable');
    popoverCorrected.setAttribute('contenteditable', 'true');
    popoverOriginal.textContent = correction.original || '';
    popoverCorrected.textContent = correction.corrected || '';
  }

  suggestionPopover.classList.add('visible');
  element.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function hidePopover() {
    suggestionPopover.classList.remove('visible');
    document.querySelectorAll('.suggestion.active').forEach(el => el.classList.remove('active'));
}

function navigateCorrections(direction) {
    if (corrections.length === 0) return;
    
    const newIndex = currentIndex + direction;
    
    if (newIndex >= 0 && newIndex < corrections.length) {
        currentIndex = newIndex;
        updateActiveCorrection();
    }
}

function updateNavigation() {
    const correctionControls = document.getElementById('correctionControls');
    
    // Handle Correction Navigation
    if (corrections.length > 0 && currentIndex > -1) {
        correctionControls.style.display = 'flex';
        navInfo.textContent = `${currentIndex + 1} / ${corrections.length}`;
        prevBtn.disabled = currentIndex <= 0;
        nextBtn.disabled = currentIndex >= corrections.length - 1;
    } else {
        correctionControls.style.display = 'none';
    }

    const isCard = corrections.length > 0 && currentIndex > -1 && corrections[currentIndex].type === 'flashcard';
    if (regenBtn)   regenBtn.style.display   = isCard ? 'inline-block' : 'none';
    if (splitBtn)   splitBtn.style.display   = isCard ? 'inline-block' : 'none';
    if (reverseBtn) reverseBtn.style.display = isCard ? 'inline-block' : 'none';
    if (newFromHighlightBtn) newFromHighlightBtn.style.display = isCard ? 'inline-block' : 'none';

    // Handle Selection Actions
    if (selectionMode && selectedText) {
        selectionActions.style.display = 'flex';
        const proofKeywords = /\\(?:theorem|proposition|lemma|proof)|\b(?:theorem|proposition|lemma|proof)\b/i;
        const hasProofContent = proofKeywords.test(selectedText);
        proofBtn.style.display = hasProofContent ? 'block' : 'none';
    } else {
        selectionActions.style.display = 'none';
    }
}

function acceptCorrection(index) {
  if (index < 0 || index >= corrections.length) return;

  const correction = corrections[index];

  // FLASHCARD MODE
  if (correction.type === 'flashcard') {
    const front = (popoverOriginal.textContent || '').trim();
    const back  = (popoverCorrected.textContent || '').trim();

    undoStack.push({
      action: 'accept_card',
      correction: { ...correction },
      index,
      card: { front, back },
      textBefore: documentInput.value
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    acceptedFlashcards.push({ front, back });
    updateFlashcardsOutput();

    corrections.splice(index, 1);
    if (corrections.length === 0) {
      resetState();
    } else {
      currentIndex = Math.min(index, corrections.length - 1);
      updateActiveCorrection();
    }
    return;
  }

  // LEGACY path (grammar/style) if you keep them
  const editedCorrectionText = popoverCorrected.textContent;
  const lengthDiff = editedCorrectionText.length - (correction.position.end - correction.position.start);
  undoStack.push({
    action: 'accept',
    correction: { ...correction },
    index: index,
    textBefore: documentInput.value,
    lengthDiff: lengthDiff
  });
  undoBtn.style.display = 'flex';

  redoStack.length = 0;
  if (redoBtn) redoBtn.style.display = 'none';

  let currentText = documentInput.value;
  currentText = currentText.substring(0, correction.position.start) +
               editedCorrectionText +
               currentText.substring(correction.position.end);
  documentInput.value = currentText;

  corrections.splice(index, 1);
  for (let i = index; i < corrections.length; i++) {
    corrections[i].position.start += lengthDiff;
    corrections[i].position.end += lengthDiff;
  }

  if (corrections.length === 0) resetState();
  else { currentIndex = Math.min(index, corrections.length - 1); updateActiveCorrection(); }
}

function rejectCorrection(index) {
  if (index < 0 || index >= corrections.length) return;

  const item = corrections[index];
  if (item.type === 'flashcard') {
    // --- UNDO for rejecting a card suggestion ---
    undoStack.push({
      action: 'reject_card',
      correction: { ...item },
      index,
      // textBefore is unchanged but safe to keep
      textBefore: documentInput.value
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    corrections.splice(index, 1);
    if (corrections.length === 0) {
      resetState();
      updateHighlightOverlay();
    } else {
      currentIndex = Math.min(index, corrections.length - 1);
      updateActiveCorrection();
    }
    return;
  }

  // Existing legacy (grammar/style) path...
  // (your current code continues here)
}

// Modal functions
function showAboutModal() {
  aboutModal.classList.add('visible');
  aboutOverlay.classList.add('visible');
}

function closeAboutModal() {
  aboutModal.classList.remove('visible');
  aboutOverlay.classList.remove('visible');
}

function showFileModal() {
  fileModal.classList.add('visible');
  fileOverlay.classList.add('visible');
}

function closeFileModal() {
  fileModal.classList.remove('visible');
  fileOverlay.classList.remove('visible');
  dropZone.classList.remove('dragging');
}


// File handling functions
function handleDragOver(e) {
  e.preventDefault();
  dropZone.classList.add('dragging');
}

function handleDragLeave(e) {
  e.preventDefault();
  dropZone.classList.remove('dragging');
}

function handleDrop(e) {
  e.preventDefault();
  dropZone.classList.remove('dragging');
  
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    processFile(files[0]);
  }
}

function handleFileSelect(e) {
  const files = e.target.files;
  if (files.length > 0) {
    processFile(files[0]);
  }
}

function processFile(file) {
  // Check file extension
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.tex') && !fileName.endsWith('.txt')) {
    alert('Please select a .tex or .txt file');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    documentInput.value = e.target.result;
    updateHighlightOverlay();
    closeFileModal();
    resetState();
    adjustTextareaHeight();
  };
  reader.onerror = function() {
    alert('Error reading file');
  };
  reader.readAsText(file);
}

</script>

</body>
</html>