<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Modern Editor</title>
<script src="keys.js" defer></script>
<script src="styles.js" defer></script>
<style>
/* ───── Basics ───── */
:root {
  --font-serif: 'Georgia', 'Times New Roman', serif;
  --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --bg-color: #fffff8;
  --text-color: #1a1a1a;
  --border-color: #d4d4d4;
  --highlight-inactive: rgba(255, 229, 153, 0.7); /* Soft Yellow */
  --highlight-active: rgba(255, 204, 203, 1);
  --suggestion-red: #d14;
  --suggestion-green: #22863a;
  --user-highlight: rgba(100, 149, 237, 0.3); /* Soft blue for user selection */
  --rule-style: #059669;
  --sidebar-pad: 85px; /* dynamic via JS to prevent overlap */
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-serif);
  background-color: var(--bg-color);
  color: var(--text-color);
  line-height: 1.7;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* ───── Header ───── */
.header {
  position: fixed;
  top: 2rem;
  left: 0;
  z-index: 100;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: auto;
}

.hamburger-btn,
.icon-btn,
.nav-btn {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid var(--border-color);
  cursor: pointer;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.2s;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  padding: 6px;
  font-size: 1.5rem;
}

.hamburger-btn:hover, .icon-btn:hover, 
.nav-btn:hover:not(:disabled) {
  background: rgba(255, 255, 255, 1);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.icon-btn svg {
  stroke: currentColor;
}

.nav-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Correction controls */
.correction-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.nav-info {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
  text-align: center;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  color: #666;
  font-weight: 500;
}

/* Selection actions */
.selection-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.selection-btn {
  padding: 8px 12px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  white-space: nowrap;
}

.selection-btn:hover {
  background: #1d4ed8;
}

.selection-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* Main content with left margin */
.main-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 2rem;
  padding-left: var(--sidebar-pad, 85px); /* Space for the sidebar (dynamic) */
  position: relative;
}

/* Responsive: ensure content doesn't overlap on narrow viewports */
@media (max-width: 600px) {
  .main-content {
    padding-left: var(--sidebar-pad, 80px);
  }
  
  .header {
    padding: 8px;
  }
  
  .hamburger-btn,
  .icon-btn,
  .nav-btn {
    width: 36px;
    height: 36px;
  }
}


.header-actions {
  display: flex;
  gap: 8px;
}

/* Hamburger Menu */
.hamburger-menu {
  position: fixed;
  top: 0;
  left: -300px;
  width: 300px;
  height: 100vh;
  background: var(--bg-color);
  border-right: 1px solid var(--border-color);
  z-index: 1000;
  transition: left 0.3s ease;
  overflow-y: auto;
}

.hamburger-menu.open {
  left: 0;
}

.analysis-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: 100%;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}

.nav-arrow-group {
    display: flex;
    gap: 8px;
}

/* Styles the smaller arrow buttons within the new layout */
.nav-arrow-group .nav-btn {
    flex: 1; /* Makes both buttons share the width equally */
    width: auto; /* Overrides the default fixed width */
    height: 36px; /* Makes the buttons shorter */
    padding: 0;
    font-size: 1.2rem;
}


.menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.3);
  z-index: 999;
  display: none;
}

.menu-overlay.visible {
  display: block;
}


.menu-style-select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 0.85rem;
  margin-top: 8px;
  background: white;
}

.menu-header {
  padding: 20px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.menu-header h2 {
  font-size: 1.2rem;
  font-weight: 500;
}

.menu-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 4px 8px;
}

.menu-content {
  padding: 20px;
}

.menu-item {
  width: 100%;
  padding: 12px 16px;
  background: none;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  margin-bottom: 12px;
  cursor: pointer;
  text-align: left;
  font-size: 0.9rem;
  transition: all 0.2s;
}

.menu-item:hover {
  background: #f0f0f0;
}

.menu-divider {
  margin: 20px 0;
  border: none;
  border-top: 1px solid var(--border-color);
}

.menu-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  cursor: pointer;
  font-size: 0.9rem;
}

.menu-toggle input {
  cursor: pointer;
}

.menu-select-group {
  margin-top: 16px;
  padding: 0 16px;
}

.menu-select-group label {
  display: block;
  margin-bottom: 8px;
  font-size: 0.9rem;
  color: #666;
}

.menu-select-group select {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 0.9rem;
}

.analyze-btn {
  padding: 8px 12px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  white-space: nowrap;
  width: 100%; /* Make them fill the sidebar width */
}

.analyze-btn:hover {
  background: #111;
}

/* Correction actions (left toolbar) */
.correction-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-color);
}
.correction-actions .popover-btn {
  width: 100%;
  padding: 8px; /* Give them more vertical space */
}

.control-label {
    font-size: 0.8rem;
    color: #666;
    font-family: var(--font-sans);
}

.api-key-input {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.85rem;
  font-family: var(--font-sans);
  background: white;
  color: var(--text-color);
  -webkit-appearance: none;
  appearance: none;
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.25em;
  padding-right: 2rem;
  width: 200px;
  background-image: none;
}


/* ───── Main Content Layout ───── */
.editor-wrapper {
  max-width: 80ch;
  margin: 0 auto;
  position: relative;
}

/* ───── Editor & Highlight Overlay ───── */
.editor-textarea, .highlight-overlay {
  width: 100%;
  min-height: 50vh;
  padding: 1rem;
  font-family: var(--font-serif);
  font-size: 18px;
  line-height: 1.7;
  border: 1px solid transparent;
  background: transparent;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
  color: var(--text-color);
}

/* Default: normal page flow (no inner scroll, no overlay stacking) */
.editor-textarea {
  position: relative;
  top: auto;
  left: auto;
  height: auto;
  resize: none;
  outline: none;
  z-index: 2;
  color: var(--text-color);
  overflow: hidden; /* let the PAGE scroll, not the textarea */
}

/* Only when overlay/highlights are active do we stack it over the overlay */
.overlay-active .editor-textarea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  overflow: hidden; /* no inner scroll while overlay is active */
  color: transparent;
  caret-color: var(--text-color);
}

/* Hide duplicate foreground text when overlay highlights are active */
.overlay-active .editor-textarea::selection {
  background: rgba(38,132,255,.25);
}

.overlay-active .highlight-overlay { display: block; }

.highlight-overlay {
  position: relative;
  z-index: 1;
  pointer-events: none;
  display: none;
}

/* ───── Suggestion Highlighting ───── */
.suggestion {
  background-color: var(--highlight-inactive);
  border-radius: 3px;
  cursor: pointer;
  pointer-events: all;
  transition: background-color 0.3s;
  scroll-margin-bottom: 110px; 
}

.suggestion.active {
  background-color: var(--highlight-active);
}

.suggestion .badge {
  font-size: 0.75em;
  margin-left: 4px;
  vertical-align: super;
  opacity: 0.8;
}

/* ───── User Selection Highlighting ───── */
.user-selection {
  background-color: var(--user-highlight);
  border-radius: 3px;
  position: relative;
}

/* ───── Suggestion Popover ───── */
.suggestion-popover {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10;
  background: rgba(255, 255, 248, 0.98);
  border-top: 2px solid #ccc;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
  padding: 16px 20px; 
  font-family: var(--font-sans);
  font-size: 0.9rem;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}

.suggestion-popover.visible {
  transform: translateY(0);
}


.selection-disabled-hint {
  color: var(--suggestion-red);
  font-style: italic;
  font-size: 0.8rem;
  margin: 0 auto; /* Center it a bit */
  display: none; /* Hidden by default */
}

.popover-counter {
  position: absolute;
  top: 10px;
  right: 20px;
  font-size: 0.85rem;
  color: #666;
  font-weight: 500;
}

.popover-diff {
  font-size: 1rem;
  line-height: 1.6;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  max-width: 800px;
  margin: 0 auto;
}

.popover-actions {
  margin-top: 16px;
  display: flex;
  gap: 12px;
  justify-content: center;
  max-width: 400px;
  margin: 16px auto 0;
}

.popover-explanation {
  font-style: italic;
  color: #555;
  margin-bottom: 16px;
  text-align: center;
  max-width: 800px;
  margin: 0 auto 16px;
}

.popover-diff del {
  color: var(--suggestion-red);
  text-decoration: none;
  background-color: #ffebe9;
  padding: 2px 4px;
  border-radius: 3px;
}

.popover-diff ins {
  color: var(--suggestion-green);
  text-decoration: none;
  background-color: #e6ffed;
  padding: 2px 4px;
  border-radius: 3px;
}

.popover-btn {
  padding: 4px 16px;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  background: white;
  font-size: 0.8rem;
  transition: all 0.2s;
}

.popover-btn.accept:hover {
  background: #e6ffed;
  border-color: var(--suggestion-green);
  color: var(--suggestion-green);
}
.popover-btn.reject:hover {
  background: #ffebe9;
  border-color: var(--suggestion-red);
  color: var(--suggestion-red);
}

/* Re-generate hint box */
.popover-tools {
  max-width: 800px;
  margin: 12px auto 0;
  display: flex;
  justify-content: center;
}
.regen-hint-input {
  width: 100%;
  max-width: 600px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 6px 10px;
  font-size: 0.9rem;
  font-family: var(--font-sans);
  background: #fff;
}

/* ───── Summary Modal (used for proofs and simplifications) ───── */
.summary-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 600px;
  max-width: 90vw;
  max-height: 80vh;
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 24px;
  font-family: var(--font-sans);
  overflow-y: auto;
  z-index: 100;
  display: none;
}

.summary-modal.visible {
  display: block;
}

.summary-modal h2 {
  font-size: 1.3rem;
  margin-bottom: 16px;
  font-weight: 500;
}

.summary-section {
  margin-bottom: 20px;
}

.summary-section h3 {
  font-size: 1rem;
  font-weight: 600;
  color: #444;
  margin-bottom: 8px;
}

.summary-section p,
.summary-section ul {
  color: #666;
  line-height: 1.6;
}

.summary-section ul {
  margin-left: 20px;
}

.locked {
  pointer-events: none;
}

.simplification-option {
  margin-bottom: 16px;
  padding: 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  transition: all 0.2s;
  cursor: pointer;
}

.simplification-option:hover {
  background: #f8f8f8;
  border-color: #999;
}

.simplification-label {
  font-weight: 600;
  color: #444;
  margin-bottom: 4px;
  font-size: 0.85rem;
}

.simplification-text {
  color: #222;
  line-height: 1.6;
}

.summary-close {
  position: absolute;
  top: 16px;
  right: 16px;
  background: none;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: #666;
  padding: 4px 8px;
}

.summary-close:hover {
  color: #222;
}

.popover-diff ins[contenteditable="true"]:focus {
  outline: 1px solid #888;
  box-shadow: 0 0 3px rgba(0,0,0,0.1);
  background-color: #fff; /* Make background solid white on focus for better editing */
}

/* ───── Modal Overlay ───── */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  z-index: 99;
  display: none;
}

.modal-overlay.visible {
  display: block;
}

.regen-area {
  width: 100%;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 10px;
  font-family: var(--font-sans);
  font-size: 0.95rem;
  background: #fff;
  margin: 8px 0 12px;
}
.regen-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

/* ───── Loading & Empty State ───── */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 248, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  font-family: var(--font-sans);
}

.loading-content { text-align: center; }
.loading-spinner {
  border: 2px solid #ccc;
  border-top: 2px solid #333;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  animation: spin 1s linear infinite;
  margin: 0 auto 16px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.loading-text { font-size: 0.9rem; color: #666; font-style: italic; }

.empty-state {
    text-align: center;
    padding: 4rem 1rem;
    color: #888;
    font-family: var(--font-sans);
}
.empty-state h3 { font-weight: 500; font-size: 1.1rem; }
.empty-state p { font-style: italic; margin-top: 0.5rem; }

/* ───── About Modal ───── */
.about-modal {
  position: fixed;
  /* Instead of centering perfectly, pin near the top so header never clips */
  top: 5vh;
  left: 50%;
  transform: translateX(-50%);
  width: 1200px;
  max-width: 90vw;

  /* Key bits so long content is readable */
  max-height: 90vh;
  overflow-y: auto;
  scrollbar-gutter: stable both-edges;
  overscroll-behavior: contain;

  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 100;
  display: none;
}

.about-modal.visible {
  display: block;
}

.about-modal h2 {
  font-size: 1.4rem;
  margin-bottom: 20px;
  font-weight: 500;
}

.about-modal h3 {
  font-size: 1.1rem;
  margin-top: 20px;
  margin-bottom: 10px;
  font-weight: 600;
  color: #444;
}

.about-modal p {
  line-height: 1.6;
  color: #666;
  margin-bottom: 12px;
}

.about-modal ul {
  margin-left: 20px;
  color: #666;
  line-height: 1.8;
}

.about-modal a {
  color: #2563eb;
  text-decoration: none;
}

.about-modal a:hover {
  text-decoration: underline;
}

/* ───── File Upload Modal ───── */
.file-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  max-width: 90vw;
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 100;
  display: none;
}

.file-modal.visible {
  display: block;
}

.file-modal h2 {
  font-size: 1.2rem;
  margin-bottom: 20px;
  font-weight: 500;
  text-align: center;
}

.drop-zone {
  border: 2px dashed #ccc;
  border-radius: 8px;
  padding: 40px;
  text-align: center;
  transition: all 0.3s;
  cursor: pointer;
  background: #fafafa;
}

.drop-zone:hover {
  border-color: #999;
  background: #f5f5f5;
}

.drop-zone.dragging {
  border-color: #2563eb;
  background: #e0e7ff;
}

.drop-zone p {
  color: #666;
  margin-bottom: 16px;
}

.file-input {
  display: none;
}

.file-btn {
  padding: 8px 20px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.2s;
}

.file-btn:hover {
  background: #111;
}
.api-key-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--bg-color);
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.15);
  padding: 32px;
  font-family: var(--font-sans);
  z-index: 1001;
  text-align: center;
  max-width: 400px;
  width: 90%;
}

.api-key-modal h2 {
  font-size: 1.2rem;
  margin-bottom: 12px;
  font-weight: 500;
}

.api-key-modal p {
  color: #666;
  margin-bottom: 20px;
  font-size: 0.9rem;
  line-height: 1.5;
}

.api-key-modal input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.9rem;
  margin-bottom: 16px;
  font-family: monospace;
}

.api-key-modal button {
  padding: 8px 24px;
  background: #333;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.2s;
}

.api-key-modal button:hover {
  background: #111;
}

/* ───── Flashcards Panel ───── */
.flashcards-section {
  max-width: 80ch;
  margin: 2rem auto 0;
  border: 1px dashed var(--border-color);
  background: rgba(255,255,255,0.6);
  border-radius: 6px;
  padding: 12px;
}
.flashcards-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-family: var(--font-sans);
}
.flashcards-output {
  width: 100%;
  min-height: 140px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  padding: 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: #fff;
  color: #222;
  resize: vertical;
}

.flashcards-prefs {
  display: flex;
  align-items: center;
  gap: 8px;
  font-family: var(--font-sans);
  font-size: 0.85rem;
}
.flashcards-prefs select {
  padding: 4px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: #fff;
}
.flashcards-prefs input[type="checkbox"] {
  transform: translateY(1px);
}

#tagsPreview code {
  background: #f6f8fa;
  border: 1px solid #e1e4e8;
  border-radius: 3px;
  padding: 2px 4px;
  margin-right: 4px;
  display: inline-block;
}

/* Make both sides editable look consistent */
.popover-diff del[contenteditable="true"]:focus,
.popover-diff ins[contenteditable="true"]:focus {
  outline: 1px solid #888;
  box-shadow: 0 0 3px rgba(0,0,0,0.1);
  background-color: #fff;
}

/* Label the popover fields as Front and Back when we're using flashcards */
.popover-diff del::before {
  content: 'Front: ';
  font-weight: 600;
  color: #666;
}
.popover-diff ins::before {
  content: 'Back: ';
  font-weight: 600;
  color: #666;
}

/* --- Accepted Flashcards: right-aligned, compact, with tooltips --- */
.flashcards-actions {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-left: auto;
}
.flashcards-actions .icon-btn {
  width: 32px;
  height: 32px;
  padding: 4px;
  font-size: 1rem;
}
.flashcards-actions .icon-btn[aria-label] { position: relative; }
.flashcards-actions .icon-btn[aria-label]::after {
  content: attr(aria-label);
  position: absolute;
  top: -30px;
  right: 0;
  background: #111;
  color: #fff;
  padding: 3px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  opacity: 0;
  transform: translateY(5px) scale(.98);
  transition: opacity .15s ease, transform .15s ease;
  pointer-events: none;
}
.flashcards-actions .icon-btn[aria-label]:hover::after {
  opacity: 1;
  transform: translateY(0) scale(1);
}

/* --- Responsive left toolbar: icon-only on narrower widths --- */
@media (max-width: 1100px) {
  .header { width: 56px; }

  .selection-actions .selection-btn {
    width: 36px;
    height: 36px;
    padding: 0;
    font-size: 0;         /* hide label text */
    line-height: 36px;
    text-align: center;
    position: relative;
  }
  .selection-actions .selection-btn::before {
    content: attr(data-short); /* single letter/icon */
    font-size: 1rem;
  }
  .selection-actions .selection-btn::after {
    content: attr(title);      /* full label on hover */
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%);
    background: #fff;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 12px;
    color: #333;
    white-space: nowrap;
    display: none;
    z-index: 100;
  }
  .selection-actions .selection-btn:hover::after { display: block; }

  /* Keep nav arrows compact too */
  .nav-arrow-group .nav-btn {
    min-width: 36px;
    width: 36px;
  }

  /* Avoid super-wide sidebar when edit buttons are visible */
  .correction-actions {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: flex-start;
    gap: 6px;
  }
  .correction-actions .popover-btn {
    padding: 0;
    min-width: 36px;
    width: 36px;
    height: 32px;
    font-size: 0; /* hide long labels */
    line-height: 32px;
    position: relative;
  }
  .correction-actions .popover-btn::before {
    content: attr(data-short); /* icon/letter */
    font-size: 0.95rem;
  }
  .correction-actions .popover-btn::after {
    content: attr(title);
    position: absolute;
    left: 40px;
    top: 50%;
    transform: translateY(-50%);
    background: #fff;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 12px;
    color: #333;
    white-space: nowrap;
    display: none;
    z-index: 100;
  }
  .correction-actions .popover-btn:hover::after { display: block; }
}

/* ===== Compact left pane (≤1000px) — square icons + fly-out labels on hover ===== */
@media (max-width: 1100px) {

  /* Never let buttons decide the sidebar width */
  .header {
    width: auto; /* keep natural, small width */
  }

  /* Flashcards (analysis) button: true icon-only square; no truncation */
  .analysis-controls .analyze-btn {
    width: 36px !important;
    height: 36px;
    padding: 0 !important;
    font-size: 0 !important;          /* hide the full label text */
    line-height: 36px;
    text-align: center;
    position: relative;
    overflow: visible;                 /* allow fly-out */
  }
  .analysis-controls .analyze-btn::before {
    content: attr(data-short);
    font-size: 1rem;
  }
  .analysis-controls .analyze-btn::after {
    content: attr(data-label);
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    background: rgba(255,255,255,0.98);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 10px;
    font-size: 0.85rem;
    color: var(--text-color);
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    opacity: 0;
    pointer-events: none;              /* no hover-capture */
    transition: opacity .12s ease, transform .12s ease;
    z-index: 1001;
  }
  .analysis-controls .analyze-btn:hover::after {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }

  /* Arrow / Undo / Redo — fixed 36px squares, no flex stretching */
  .nav-arrow-group {
    display: flex;
    flex-wrap: wrap;                   /* if 3–4 buttons, wrap to next row */
    gap: 6px;
  }
  .nav-arrow-group .nav-btn {
    flex: 0 0 36px;
    width: 36px;
    height: 36px;
    padding: 0;
    font-size: 1.2rem;                 /* arrows remain visible */
    line-height: 36px;
    text-align: center;
    position: relative;
    overflow: visible;
  }
  /* Fly-out labels for nav as well */
  .nav-arrow-group .nav-btn::after {
    content: attr(data-label);
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    background: rgba(255,255,255,0.98);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 12px;
    color: var(--text-color);
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    opacity: 0;
    pointer-events: none;
    transition: opacity .12s ease, transform .12s ease;
    z-index: 1001;
  }
  .nav-arrow-group .nav-btn:hover::after {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }

  /* Correction actions (Accept / Reject / Regen / Split / Reverse / New) — square icons */
  .correction-actions {
    flex-direction: column;            /* vertical column, keep pane narrow */
    gap: 6px;
  }
  .correction-actions .popover-btn {
    width: 36px !important;            /* override earlier width:100% */
    min-width: 36px;
    height: 32px;
    padding: 0 !important;
    font-size: 0 !important;           /* hide long labels (prevents truncation) */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: visible;
  }
  .correction-actions .popover-btn::before {
    content: attr(data-short);
    font-size: 0.95rem;
    line-height: 1;
  }
  .correction-actions .popover-btn::after {
    content: attr(data-label);
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    background: rgba(255,255,255,0.98);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 12px;
    color: var(--text-color);
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    opacity: 0;
    pointer-events: none;
    transition: opacity .12s ease, transform .12s ease;
    z-index: 1001;
  }
  .correction-actions .popover-btn:hover::after {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }

  /* Selection actions (Simplify / Proof / Make) — same behavior */
  .selection-actions .selection-btn {
    width: 36px !important;
    height: 36px;
    padding: 0 !important;
    font-size: 0 !important;
    line-height: 36px;
    text-align: center;
    position: relative;
    overflow: visible;
  }
  .selection-actions .selection-btn::before {
    content: attr(data-short);
    font-size: 1rem;
  }
  .selection-actions .selection-btn::after {
    content: attr(data-label);
    position: absolute;
    left: 42px;
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    background: rgba(255,255,255,0.98);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 12px;
    color: var(--text-color);
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    opacity: 0;
    pointer-events: none;
    transition: opacity .12s ease, transform .12s ease;
    z-index: 1001;
  }
  .selection-actions .selection-btn:hover::after {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }
}

/* Stack Undo/Redo below the arrow keys on small screens */
@media (max-width: 1000px) {
  .nav-arrow-group {
    display: grid !important;
    grid-template-columns: 36px 36px;  /* two square columns */
    grid-auto-rows: 36px;              /* one square row per line */
    gap: 6px;
    align-items: center;
    justify-items: center;
  }

  /* Ensure the buttons themselves don't try to flex/stretch */
  .nav-arrow-group .nav-btn {
    flex: initial !important;          /* override any flex: 1 */
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important;
  }

  /* Explicit placement: row / column */
  #prevBtn { grid-row: 1; grid-column: 1; }
  #nextBtn { grid-row: 1; grid-column: 2; }
  #undoBtn { grid-row: 2; grid-column: 1; }
  #redoBtn { grid-row: 2; grid-column: 2; }
}
/* Overlay sits above the textarea so chips stay clickable */
.highlight-overlay {
  z-index: 5;             /* was 1 */
  pointer-events: none;   /* pass through by default */
}

/* Chips stay clickable even with overlay above */
.highlight-overlay .suggestion {
  pointer-events: auto;   /* allow clicking suggestions */
}

/* While user is dragging a selection, disable chip clicks so drag isn't interrupted */
.sel-drag .highlight-overlay .suggestion {
  pointer-events: none !important;
}

/* Do not let the ×N badge capture clicks or enter the selection text */
.highlight-overlay .badge {
  user-select: none;
  pointer-events: none;
}
.popover-diff [contenteditable="true"]:focus {
  background: #fffbe6;
  outline: 1px solid #e0c040;
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <button class="hamburger-btn" id="hamburgerBtn">☰</button>
  <button class="nav-btn icon-btn" id="copyBtn" title="Copy Text">
    <svg class="icon-copy" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
    <svg class="icon-check" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><polyline points="20 6 9 17 4 12"></polyline></svg>
  </button>
  <button class="nav-btn icon-btn" id="downloadBtn" title="Download as .txt">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
  </button>

  <!-- Wrapper for analysis button to add the line above -->
  <div class="analysis-controls">
  <button class="selection-btn analyze-btn" id="analyzeFlashcardsBtn"
        title="Flashcards" aria-label="Flashcards"
        data-short="F" data-label="Flashcards">Flashcards</button>
  </div>


  <!-- Navigation controls (visible during corrections) -->
  <div class="correction-controls" id="correctionControls" style="display: none;">
    <div class="nav-info" id="navInfo">0 / 0</div>
    <!-- Wrapper for side-by-side arrows -->
    <div class="nav-arrow-group">
        <button class="nav-btn" id="prevBtn" title="Previous" aria-label="Previous" data-label="Previous">←</button>
        <button class="nav-btn" id="nextBtn" title="Next"     aria-label="Next"     data-label="Next">→</button>
        <button class="nav-btn" id="undoBtn" title="Undo Last Action (⎌)" aria-label="Undo" data-label="Undo" style="display: none;">⎌</button>
        <button class="nav-btn" id="redoBtn" title="Redo Last Undo (⇧⌘Z / Ctrl+Shift+Z)" aria-label="Redo" data-label="Redo" style="display: none;">⤻</button>
    </div>
    <!-- Accept/Reject buttons are now correctly inside this container -->
    <div class="correction-actions">
        <button class="popover-btn reject" id="popoverRejectBtn"
        data-short="✖" data-label="Reject" title="Reject card">Reject</button>
        <button class="popover-btn accept" id="popoverAcceptBtn"
                data-short="✓" data-label="Accept" title="Accept card">Accept</button>
        <button class="popover-btn" id="regenBtn"
                data-short="↻" data-label="Re‑generate" title="Re‑generate variants based on hint">↻ Re‑generate</button>
        <button class="popover-btn" id="splitBtn"
                data-short="⇄" data-label="Split (2)" title="Split this card into exactly two atomic cards">Split (2)</button>
        <button class="popover-btn" id="reverseBtn"
                data-short="⇅" data-label="Reverse" title="Generate a reversed version of this card">Reverse</button>
        <button class="popover-btn" id="newFromHighlightBtn"
                data-short="＋" data-label="New from Highlight" title="Create a NEW card using this highlight and your hint">＋ New from Highlight</button>
    </div>
  </div>
  
  <!-- Selection actions (visible when text selected) -->
  <div class="selection-actions" id="selectionActions" style="display: none;">
    <button class="selection-btn" id="simplifyBtn" title="Simplify"     data-short="S" data-label="Simplify">Simplify</button>
    <button class="selection-btn" id="proofBtn"    title="Check Proof"  data-short="P" data-label="Check Proof">Check Proof</button>
    <button class="selection-btn" id="makeCardBtn" title="Make Card"    data-short="C" data-label="Make Card">Make Card</button>
  </div>
</div>

<!-- Hamburger Menu -->
<div class="hamburger-menu" id="hamburgerMenu">
  <div class="menu-header">
    <h2>Modern Editor</h2>
    <button class="menu-close" id="menuClose">×</button>
  </div>
  <div class="menu-content">
    <button class="menu-item" id="helpBtn" style="background-color:#000000; color:#FFFFFF;">Help</button>
    <hr class="menu-divider">
    <button class="menu-item" id="newDocBtn">Load New Document</button>

    <!-- Swap provider button -->
    <button class="menu-item" id="swapAIProviderBtn">
      AI Provider: <span id="currentProviderLabel">Gemini</span> (tap to switch)
    </button>
    <hr class="menu-divider">

    <div class="menu-select-group">
    <select id="ruleSelect" style="display: none;">
      <!-- Options will be populated from rules.js -->
    </select>
    <div class="menu-select-group">
      <label for="languageSelect">Language:</label>
      <select id="languageSelect">
        <option value="en-US">English (US)</option>
        <option value="en-CAN">English (CAN)</option>
        <option value="en-UK">English (UK)</option>
        <option value="fr">French</option>
        <option value="es">Spanish</option>
        <option value="de">German</option>
      </select>
    </div>
    <div class="menu-select-group">
      <label for="styleSelect">Flashcard Domain:</label>
      <select id="styleSelect" class="menu-style-select">
        <!-- Options will be populated from rules.js -->
      </select>
    </div>
    <div class="menu-select-group">
      <label for="depthSelect">Flashcard Depth:</label>
      <select id="depthSelect">
        <option value="shallow">Shallow</option>
        <option value="medium" selected>Medium</option>
        <option value="complete">Complete</option>
      </select>
    </div>
    <label class="menu-toggle">
      <input type="checkbox" id="freeModelsCheckbox">
      <span>Use free LLM models only</span>
    </label>
    </div>
  </div>
</div>
<div class="menu-overlay" id="menuOverlay"></div>

<!-- Main Content -->
<main class="main-content" id="mainContent">
  <div class="editor-wrapper">
    <div class="highlight-overlay" id="highlightOverlay"></div>
    <textarea class="editor-textarea" id="documentInput" placeholder="Paste or write your document here..."></textarea>
  </div>

  <!-- Accepted Flashcards Panel -->
  <section class="flashcards-section" id="flashcardsSection">
    <div class="flashcards-header">
      <h3>Accepted Flashcards</h3>
      <div class="flashcards-actions">
        <button class="nav-btn icon-btn" id="copyFlashcardsBtn" title="Copy Flashcards" aria-label="Copy flashcards to clipboard">
          <!-- reuse the clipboard icon -->
          <svg class="icon-copy" xmlns="http://www.w3.org/2000/svg" width="16" height="16"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
        <button class="nav-btn icon-btn" id="downloadFlashcardsBtn" title="Download flashcards (.txt)" aria-label="Download flashcards as .txt file">
          <!-- reuse the download icon -->
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        </button>
        <!-- NEW: Download .md -->
        <button class="nav-btn icon-btn" id="downloadFlashcardsMDBtn" title="Download as .md (Markdown)" aria-label="Download flashcards as Markdown (.md)">
          <!-- identical icon is fine -->
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
              viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        </button>
        <button class="nav-btn icon-btn" id="exportSettingsBtn" title="Export Settings" aria-label="Export settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 8.12 4 1.65 1.65 0 0 0 9 2.49V2a2 2 0 1 1 4 0v.09c.45.17.83.49 1 1a1.65 1.65 0 0 0 1.51 1h.09a2 2 0 1 1 0 4h-.09c-.52 0-1.02.2-1.39.57A1.65 1.65 0 0 0 13 10.91V11a1 1 0 0 1-2 0v-.09"></path>
        </svg>
      </button>
      </div>
    </div>
     <!-- ADD THIS PREFERENCES BAR -->
    <div class="flashcards-prefs" style="margin-bottom:8px;">
      <label for="exportStyleSelect" class="control-label">Export:</label>
      <select id="exportStyleSelect">
        <option value="neuracache">Neuracache</option>
        <option value="anki">Anki</option>
        <option value="remnote">Remnote</option>
        <option value="raw">Raw (Front ⏎ Back)</option>
      </select>

      <label for="includeSourceCheckbox" class="control-label" style="margin-left:12px;">
        <input type="checkbox" id="includeSourceCheckbox"> Include source material
      </label>
    </div>

    <textarea id="flashcardsOutput" class="flashcards-output"
      placeholder="Export preview appears here (changes with preferences above)."
      readonly></textarea>
  </section>
</main>


<!-- Suggestion Popover -->
<div class="suggestion-popover" id="suggestionPopover">
  <div class="popover-explanation" id="popoverExplanation"></div>
  <div class="popover-diff">
    <del id="popoverOriginal"></del> 
    → 
    <ins id="popoverCorrected" contenteditable="true"></ins>
  </div>
</div>

<!-- Simplification Modal -->
<div class="modal-overlay" id="simplificationOverlay"></div>
<div class="summary-modal" id="simplificationModal">
  <button class="summary-close" id="simplificationModalClose">×</button>
  <h2>Simplification Options</h2>
  <div class="summary-section">
    <h3>Original Text</h3>
    <p id="simplificationOriginal" style="background: #f5f5f5; padding: 12px; border-radius: 4px; font-style: italic;"></p>
  </div>
  <div id="simplificationOptions"></div>
</div>

<!-- Action Hint Modal (replaces the old 'regen' modal) -->
<!-- Note: ensure regenOverlay, Modal, Close, HintArea etc. are all relabeled! -->
<div class="modal-overlay" id="actionOverlay"></div>
<div class="summary-modal" id="actionModal">
  <button class="summary-close" id="actionClose">×</button>
  <h2 id="actionTitle">Action</h2>
  <p class="control-label" id="actionPrompt">Optional instructions:</p>
  <textarea id="actionHintArea" class="regen-area" rows="4"></textarea>
  <div class="regen-actions">
    <button class="popover-btn" id="actionCancel">Cancel</button>
    <button class="popover-btn accept" id="actionSubmit">Submit</button>
  </div>
</div>

<!-- Export Settings Modal -->
<div class="modal-overlay" id="exportOverlay"></div>
<div class="summary-modal" id="exportModal" style="max-width: 700px;">
  <button class="summary-close" id="exportClose">×</button>
  <h2>Export Settings</h2>

  <div class="summary-section">
    <label class="menu-toggle">
      <input type="checkbox" id="includeMetadataCheckbox">
      <span>Include metadata/front-matter block</span>
    </label>

    <label class="menu-toggle" style="margin-top:8px;">
      <input type="checkbox" id="generateTagsCheckbox">
      <span>Generate tags with AI (Wikipedia fields)</span>
    </label>

    <div style="display:flex; gap:8px; margin-top:8px;">
      <input type="text" id="metaAuthorInput" placeholder="Author (e.g., wikipedia.org)" style="flex:1; padding:6px;">
      <input type="text" id="metaDeckInput" placeholder="TARGET DECK (e.g., All Cards)" style="flex:1; padding:6px;">
    </div>
  </div>

  <div class="summary-section">
    <h3>Metadata Template</h3>
    <p class="control-label" style="margin-bottom:6px;">
      Available placeholders: <code>{{author}}</code>, <code>{{deck}}</code>, <code>{{created}}</code>, <code>{{modified}}</code>, <code>{{tags}}</code>
    </p>
    <textarea id="metadataTemplate" class="regen-area" rows="8">---
    Author: {{author}}
    TARGET DECK: {{deck}}
    TAGS:
    {{tags}}
    created: {{created}}
    modified: {{modified}}
    ---</textarea>

    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
      <button class="popover-btn" id="genTagsNowBtn">Generate tags now</button>
      <button class="popover-btn accept" id="exportSaveBtn">Save</button>
    </div>

    <div id="tagsPreview" style="margin-top:8px; font-family:var(--font-sans); font-size:.9rem; color:#444;"></div>
  </div>
</div>


<!-- Loading overlay -->
<div class="loading-overlay" id="loadingOverlay" style="display: none;">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Analyzing...</div>
  </div>
</div>

<!-- Summary Modal -->
<div class="modal-overlay" id="modalOverlay"></div>
<div class="summary-modal" id="summaryModal">
  <button class="summary-close" id="summaryClose">×</button>
  <h2>Document Summary</h2>
  <div id="summaryContent"></div>
</div>

<!-- About Modal -->
<div class="modal-overlay" id="aboutOverlay"></div>
<div class="about-modal" id="aboutModal">
  <button class="summary-close" id="aboutClose">×</button>

  <h2>Flashcard Generator (September 2025)</h2>
  <p>Created by <strong>DJ Thornton</strong><br>
     Postdoctoral Research Fellow, Manos Institute for Cognitive Economics, UNSW Sydney</p>

  <!-- CREDIT WHERE CREDIT IS DUE! -->
  <p style="margin-top:-6px;">
    <em>A huge thanks to <a href="https://kevinbryanecon.com/ModernEditor/" target="_blank">Kevin Bryan’s Modern Editor</a> for inspiring this project.</em>
  </p>

  <p>
    <a href="https://djthornton.org" target="_blank">djthornton.org</a><br>
    <a href="mailto:d.thornton@unsw.edu.au">d.thornton@unsw.edu.au</a>
  </p>

  <h3>What this app does</h3>
  <ul>
    <li><strong>Generate flashcards from text:</strong> The model creates Q/A cards anchored to exact source snippets so you can trace every card back to the document.</li>
    <li><strong>Accept / Reject cards:</strong> Quickly curate only the cards you want. Accepted cards accumulate in the panel at the bottom (ready to copy/download).</li>
  </ul>

  <h3>Editing tools on each card</h3>
  <ul>
    <li><strong>↻ Regenerate:</strong> Rewrites the current card using your instructions (modal). Replaces the card in place.</li>
    <li><strong>Split (2):</strong> Splits one card into exactly two atomic cards. Replaces the original with the first split and inserts the second right after.</li>
    <li><strong>Reverse:</strong> Creates an additional, reversed card (original stays). Avoids meta “what question would…” wording.</li>
    <li><strong>＋ New from Highlight:</strong> Always opens a prompt box. Uses the highlighted source + current card as context to create a <em>new</em> related card (e.g., request a definition or acronym expansion).</li>
  </ul>

  <h3>Make a card from selected text</h3>
  <ul>
    <li><strong>Make Card:</strong> Select any text in the editor and click <em>Make Card</em> (in the left panel) to generate cards strictly from the selection (context is used only to disambiguate).</li>
  </ul>

  <h3>Keyboard shortcuts</h3>
  <ul>
    <li><strong>← / →</strong>: Navigate cards</li>
    <li><strong>Enter</strong>: Accept current flashcard</li>
    <li><strong>Backspace / Delete</strong>: Reject current flashcard</li>
    <li><strong>⎌ (button)</strong>: Undo last action &nbsp;•&nbsp; <strong>⇧⌘Z / Ctrl+Shift+Z</strong>: Redo</li>
    <li><strong>s</strong>: Split (immediate) &nbsp;•&nbsp; <strong>Ctrl/⌘+s</strong>: Split with modal hint</li>
    <li><strong>r</strong>: Reverse (immediate) &nbsp;•&nbsp; <strong>Ctrl/⌘+r</strong>: Reverse with modal hint</li>
    <li><strong>a</strong>: Regenerate (opens modal)</li>
    <li><strong>n</strong>: New from Highlight (opens modal)</li>
  </ul>

  <p style="color:#666; font-size:0.9rem;">
    Tips: Keep each card <em>atomic</em> (one idea on the back) and <em>univocal</em> (a single correct answer on the front). Markdown/LaTeX is supported in both fields.
  </p>
</div>


<!-- File Upload Modal -->
<div class="modal-overlay" id="fileOverlay"></div>
<div class="file-modal" id="fileModal">
  <button class="summary-close" id="fileClose">×</button>
  <h2>Open File</h2>
  <div class="drop-zone" id="dropZone">
    <p>Drag and drop a .tex or .txt file here</p>
    <p style="margin-bottom: 8px; font-size: 0.9rem;">or</p>
    <button class="file-btn" id="fileSelectBtn">Choose File</button>
    <input type="file" class="file-input" id="fileInput" accept=".tex,.txt">
  </div>
</div>

<!-- API Key Modal -->
<div class="api-key-modal" id="apiKeyModal" style="display: none;">
  <h2>Model Provider</h2>
  <p>Select a provider and enter an API key. Keys are stored locally in your browser.</p>

  <label for="providerSelect" style="display:block; text-align:left; margin-bottom:6px;">Provider:</label>
  <select id="providerSelect" style="width:100%; padding:8px; margin-bottom:12px;">
    <option value="gemini">Gemini</option>
    <option value="ultimateai">UltimateAI</option>
  </select>

  <div id="geminiFields">
    <p style="margin:0 0 6px;">Gemini key:</p>
    <input type="text" id="apiKeyInput" placeholder="Enter your Gemini API key">
    <p style="font-size:0.85rem; color:#666; margin-top:8px;">
      Get a key at https://aistudio.google.com/app/apikey
    </p>
  </div>

  <div id="ultimateFields" style="display:none;">
    <p style="margin:10px 0 6px;">UltimateAI key:</p>
    <input type="text" id="ultimateKeyInput" placeholder="Enter your UltimateAI key">
    <p style="margin:10px 0 6px;">UltimateAI model (e.g., gpt-4o-mini):</p>
    <input type="text" id="ultimateModelInput" placeholder="Enter the model name">
    <p style="font-size:0.85rem; color:#666; margin-top:8px;">
      Base URL: https://smart.ultimateai.org/v1 — Chat Completions: /chat/completions
    </p>
  </div>

  <button id="apiKeySubmit">Continue</button>
</div>

<script>
// State management
let corrections = [];
let currentIndex = -1;
let undoStack = [];
let redoStack = [];
let apiKey = '';
let selectedText = '';
let selectedRange = null;
let selectionMode = false;
let acceptedFlashcards = [];
let cachedTags = [];              // holds latest generated tags
let createdAtISO = '';            // first time we export with metadata
let pendingAction = null; // 'regenerate' | 'split' | 'reverse'
let isSelectingDrag = false;
let overlayDragState = { started: false, target: null, downX: 0, downY: 0 };

// DOM elements
const undoBtn = document.getElementById('undoBtn');
const documentInput = document.getElementById('documentInput');
const highlightOverlay = document.getElementById('highlightOverlay');
const mainContent = document.getElementById('mainContent');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const navInfo = document.getElementById('navInfo');
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');
const ruleSelect = document.getElementById('ruleSelect');
const simplificationModal = document.getElementById('simplificationModal');
const simplificationOriginal = document.getElementById('simplificationOriginal');
const simplificationOptions = document.getElementById('simplificationOptions');
const simplificationModalClose = document.getElementById('simplificationModalClose');
const simplificationOverlay = document.getElementById('simplificationOverlay');
const summaryModal = document.getElementById('summaryModal');
const summaryContent = document.getElementById('summaryContent');
const summaryClose = document.getElementById('summaryClose');
const modalOverlay = document.getElementById('modalOverlay');
const apiKeyModal = document.getElementById('apiKeyModal');
const apiKeyInput = document.getElementById('apiKeyInput');
const apiKeySubmit = document.getElementById('apiKeySubmit');
const aboutModal = document.getElementById('aboutModal');
const aboutClose = document.getElementById('aboutClose');
const aboutOverlay = document.getElementById('aboutOverlay');
const fileModal = document.getElementById('fileModal');
const fileClose = document.getElementById('fileClose');
const fileOverlay = document.getElementById('fileOverlay');
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const fileSelectBtn = document.getElementById('fileSelectBtn');
const selectionActions = document.getElementById('selectionActions');
const simplifyBtn = document.getElementById('simplifyBtn');
const proofBtn = document.getElementById('proofBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const styleSelect = document.getElementById('styleSelect');
const correctionControls = document.getElementById('correctionControls');
const flashcardsOutput = document.getElementById('flashcardsOutput');
const copyFlashcardsBtn = document.getElementById('copyFlashcardsBtn');
const downloadFlashcardsBtn = document.getElementById('downloadFlashcardsBtn');
const depthSelect = document.getElementById('depthSelect');
const makeCardBtn = document.getElementById('makeCardBtn');
const regenBtn = document.getElementById('regenBtn');
const splitBtn = document.getElementById('splitBtn');
const reverseBtn = document.getElementById('reverseBtn');
const providerSelect = document.getElementById('providerSelect');
const geminiFields = document.getElementById('geminiFields');
const ultimateFields = document.getElementById('ultimateFields');
const ultimateKeyInput = document.getElementById('ultimateKeyInput');
const ultimateModelInput = document.getElementById('ultimateModelInput');
const actionOverlay  = document.getElementById('actionOverlay');
const actionModal    = document.getElementById('actionModal');
const actionClose    = document.getElementById('actionClose');
const actionHintArea = document.getElementById('actionHintArea');
const actionCancel   = document.getElementById('actionCancel');
const actionSubmit   = document.getElementById('actionSubmit');
const actionTitle    = document.getElementById('actionTitle');
const actionPrompt   = document.getElementById('actionPrompt');
const redoBtn = document.getElementById('redoBtn');
const newFromHighlightBtn = document.getElementById('newFromHighlightBtn');
const exportStyleSelect     = document.getElementById('exportStyleSelect');
const includeSourceCheckbox = document.getElementById('includeSourceCheckbox');
const downloadFlashcardsMDBtn = document.getElementById('downloadFlashcardsMDBtn');
const exportSettingsBtn       = document.getElementById('exportSettingsBtn');
const exportModal             = document.getElementById('exportModal');
const exportOverlay           = document.getElementById('exportOverlay');
const exportClose             = document.getElementById('exportClose');
const includeMetadataCheckbox = document.getElementById('includeMetadataCheckbox');
const generateTagsCheckbox    = document.getElementById('generateTagsCheckbox');
const metaAuthorInput         = document.getElementById('metaAuthorInput');
const metaDeckInput           = document.getElementById('metaDeckInput');
const metadataTemplate        = document.getElementById('metadataTemplate');
const exportSaveBtn           = document.getElementById('exportSaveBtn');
const genTagsNowBtn           = document.getElementById('genTagsNowBtn');
const tagsPreview             = document.getElementById('tagsPreview');

/* NEW: elements for provider quick toggle & consistency */
const freeModelsCheckbox = document.getElementById('freeModelsCheckbox');
const languageSelect     = document.getElementById('languageSelect');
const swapAIProviderBtn  = document.getElementById('swapAIProviderBtn');
const currentProviderLabel = document.getElementById('currentProviderLabel');



// Hamburger elements
const hamburgerBtn = document.getElementById('hamburgerBtn');
const hamburgerMenu = document.getElementById('hamburgerMenu');
const menuClose = document.getElementById('menuClose');
const menuOverlay = document.getElementById('menuOverlay');
const helpBtn = document.getElementById('helpBtn');
const newDocBtn = document.getElementById('newDocBtn');
const analyzeFlashcardsBtn = document.getElementById('analyzeFlashcardsBtn');


// Popover elements
const suggestionPopover = document.getElementById('suggestionPopover');
const popoverExplanation = document.getElementById('popoverExplanation');
const popoverOriginal = document.getElementById('popoverOriginal');
const popoverCorrected = document.getElementById('popoverCorrected');
const popoverAcceptBtn = document.getElementById('popoverAcceptBtn');
const popoverRejectBtn = document.getElementById('popoverRejectBtn');

// Provider helpers (source of truth = localStorage 'provider')
function getStoredProvider() {
  return localStorage.getItem('provider') || 'gemini';
}
function applyProvider(newProvider) {
  const current = getStoredProvider();
  if (newProvider === current) {
    // Just ensure UI is synced; don't flip.
    if (providerSelect) providerSelect.value = newProvider;
    toggleProviderFields(newProvider);
    if (currentProviderLabel) currentProviderLabel.textContent = (newProvider === 'gemini' ? 'Gemini' : 'UltimateAI');
    return;
  }
  localStorage.setItem('provider', newProvider);
  if (providerSelect) providerSelect.value = newProvider;
  toggleProviderFields(newProvider);
  if (currentProviderLabel) currentProviderLabel.textContent = (newProvider === 'gemini' ? 'Gemini' : 'UltimateAI');
  checkApiKey(); // surface modal if key missing for the chosen provider
}
function updateProviderLabelFromStorage() {
  const p = getStoredProvider();
  if (currentProviderLabel) currentProviderLabel.textContent = (p === 'gemini' ? 'Gemini' : 'UltimateAI');
}

// Hamburger menu events
hamburgerBtn.addEventListener('click', openHamburgerMenu);
menuClose.addEventListener('click', closeHamburgerMenu);
menuOverlay.addEventListener('click', closeHamburgerMenu);

styleSelect.addEventListener('change', () => {
  const rule = window.WRITING_RULES[styleSelect.value];
  if (rule && (rule.type === 'flashcard' || rule.type === 'style')) {
    ruleSelect.value = styleSelect.value;
  }
});

helpBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  showAboutModal();
});

undoBtn.addEventListener('click', handleUndo);

newDocBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  showFileModal();
});

/* Respect user selection: the select is authoritative.
   If the user chooses the same value, we do nothing. */
if (providerSelect) {
  providerSelect.addEventListener('change', () => {
    const val = providerSelect.value;
    applyProvider(val);
  });
}

/* One-tap swap that never overrides a subsequent explicit selection.
   It simply flips the stored provider and syncs UI. */
if (swapAIProviderBtn) {
  swapAIProviderBtn.addEventListener('click', () => {
    const current = getStoredProvider();
    const next    = current === 'gemini' ? 'ultimateai' : 'gemini';
    applyProvider(next);
  });
}

analyzeFlashcardsBtn.addEventListener('click', () => {
  closeHamburgerMenu();
  // Use whatever is selected in the domain dropdown; fallback to a base flashcard rule
  const candidate = window.WRITING_RULES[styleSelect.value];
  ruleSelect.value = (candidate && candidate.type === 'flashcard') ? styleSelect.value : 'flashcards_base';
  handleAnalysis();
});


copyFlashcardsBtn.addEventListener('click', async () => {
  const text = await renderExportAsync();
  navigator.clipboard.writeText(text || '')
    .catch(err => { console.error('Failed to copy flashcards:', err); alert('Failed to copy flashcards.'); });
});

downloadFlashcardsBtn.addEventListener('click', async () => {
  const text = await renderExportAsync() || '';
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'flashcards.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

makeCardBtn.addEventListener('click', handleMakeCardFromSelection);

if (redoBtn) redoBtn.addEventListener('click', handleRedo);

function openHamburgerMenu() {
  hamburgerMenu.classList.add('open');
  menuOverlay.classList.add('visible');
  updateProviderLabelFromStorage();
  
  // If current rule is a style, update style selector
  if (ruleSelect && ruleSelect.value && window.WRITING_RULES) {
    const currentRule = window.WRITING_RULES[ruleSelect.value];
    if (currentRule && (currentRule.type === 'flashcard' || currentRule.type === 'style') && styleSelect) {
      styleSelect.value = ruleSelect.value;
    }
  }
}

function closeHamburgerMenu() {
  hamburgerMenu.classList.remove('open');
  menuOverlay.classList.remove('visible');
}

// "Drag to select" guard
documentInput.addEventListener('mousedown', (e) => {
  // If we’re reviewing cards (corrections active), allow text selection to pass everywhere
  if (corrections.length > 0) {
    isSelectingDrag = true;
    document.body.classList.add('sel-drag'); // disables chip clicks via CSS while dragging
  }
});

window.addEventListener('mouseup', (e) => {
  if (isSelectingDrag) {
    isSelectingDrag = false;
    document.body.classList.remove('sel-drag');
  }
  // If the textarea has focus, commit any selection that just finished
  if (document.activeElement === documentInput) {
    handleTextSelection();
  }
});

// Keep selection state in sync even if mouseup occurs off the textarea
document.addEventListener('selectionchange', () => {
  if (document.activeElement === documentInput) {
    handleTextSelection();
  }
});

// Let drag-select start even if initial press lands on an overlay chip.
// We capture the press, temporarily block chip hit-testing, and start a native
// selection in the textarea at the same screen coordinates.
highlightOverlay.addEventListener('mousedown', (e) => {
  if (corrections.length === 0) return; // only matters in approval mode

  overlayDragState.started = true;
  overlayDragState.target  = e.target.closest('.suggestion'); // remember chip (if any)
  overlayDragState.downX   = e.clientX;
  overlayDragState.downY   = e.clientY;

  // Enter drag mode: chips stop intercepting pointer events (CSS .sel-drag rule)
  isSelectingDrag = true;
  document.body.classList.add('sel-drag');

  // Put focus into the textarea and start a native selection at the pointer
  documentInput.focus();
  const syntheticDown = new MouseEvent('mousedown', {
    view: window, bubbles: true, cancelable: true,
    clientX: e.clientX, clientY: e.clientY
  });
  documentInput.dispatchEvent(syntheticDown);

  // Prevent the overlay press from activating the chip on mousedown
  e.preventDefault();
}, true); // NOTE: capture phase so we run before .suggestion's own click handler


// Pure string formatters (no model calls)
const EXPORTERS = {
  neuracache(cards) {
    // front #flashcard \n back \n\n
    return cards.map(c => `${c.front} #flashcard\n${c.back}`).join('\n\n');
  },
  anki(cards) {
    // Q: front \n A: back \n\n
    return cards.map(c => `Q: ${c.front}\nA: ${c.back}`).join('\n\n');
  },
  remnote(cards) {
    // front >> back \n\n
    return cards.map(c => `${c.front} >> ${c.back}`).join('\n\n');
  },
  raw(cards) {
    // front \n back \n\n
    return cards.map(c => `${c.front}\n${c.back}`).join('\n\n');
  }
};

// Compose final export string based on current UI prefs
function renderExport() {
  const styleKey = (exportStyleSelect?.value) || localStorage.getItem('exportStyle') || 'neuracache';
  const formatter = EXPORTERS[styleKey] || EXPORTERS.neuracache;

  const includeSource = (includeSourceCheckbox?.checked !== undefined)
    ? includeSourceCheckbox.checked
    : JSON.parse(localStorage.getItem('exportIncludeSource') || 'false');

  let out = formatter(acceptedFlashcards || []);

  if (includeSource) {
    const src = documentInput.value || '';
    out = `## Source Material\n${src}\n\n## Flashcards\n${out}`;
  }
  return out;
}

async function updateFlashcardsOutput() {
  if (!flashcardsOutput) return;
  flashcardsOutput.value = 'Preparing preview…';
  try {
    flashcardsOutput.value = await renderExportAsync();
  } catch {
    flashcardsOutput.value = '(Preview failed)';
  }
}

function generateSelectionFlashcardPrompt(selection, context, rule) {
  const languageInstruction = getLanguageInstruction();
  const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
  const depthInstruction = (depth === 'shallow')
    ? 'Return exactly one card for the selection.'
    : (depth === 'complete')
      ? 'Return 1–3 cards; prefer splitting into atomic cards if multiple ideas appear.'
      : 'Return 1–2 cards.';

  const domainFragment = (rule && rule.prompt) ? rule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
Create flashcards ONLY from the SELECTED text (use its CONTEXT only to disambiguate).
Atomicity & univocality required. Allow Markdown/LaTeX. Include a "source" snippet copied verbatim from the selection if possible; otherwise from the immediate context.

${depthInstruction}

Domain guidance:
${domainFragment}

Return ONLY a JSON array of 1–3 objects with keys: source, front, back, explanation (optional).

SELECTION:
\`\`\`
${selection}
\`\`\`

CONTEXT (may be used for source if needed):
\`\`\`
${context}
\`\`\`
`;
}

function generateRegenerateCardPrompt(card, hint, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  // Grab local context around the anchored span for better phrasing
  const fullText = documentInput.value;
  const ctxStart = Math.max(0, card.position.start - 400);
  const ctxEnd   = Math.min(fullText.length, card.position.end + 400);
  const context  = fullText.substring(ctxStart, ctxEnd);

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
We have an existing FLASHCARD (front/back) anchored to a source snippet. Please propose up to THREE alternative versions that better satisfy:
- Atomicity: one coherent idea per back.
- Univocality: front has a single unambiguous answer.
- Keep notation precise; allow Markdown/LaTeX ($...$ or \\[ ... \\]).

If the user hint is provided, follow it strictly: "${hint || '(no hint)'}".

Domain guidance:
${domainFragment}

Return ONLY a JSON array of 1–3 objects with keys:
- "source": short verbatim snippet (<=160 chars) from the DOCUMENT or CONTEXT (prefer original source).
- "front": revised prompt/question (may include Markdown/LaTeX).
- "back": revised answer (a single idea; may include Markdown/LaTeX).
- "explanation": optional short rationale.

DOCUMENT CONTEXT (for anchoring and wording):
\`\`\`
${context}
\`\`\`

CURRENT CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}
`;
}

function generateSplitCardPrompt(card, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
SPLIT the following FLASHCARD into EXACTLY TWO atomic cards. Keep univocal fronts, one-idea backs. Preserve notation; allow Markdown/LaTeX.

Domain guidance:
${domainFragment}

Return ONLY a JSON array with EXACTLY TWO objects:
[
  { "source": "verbatim snippet (<=160 chars)",
    "front": "univocal prompt",
    "back": "single idea answer",
    "explanation": "optional"
  },
  { ... second card ... }
]

CURRENT CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}
`;
}

function generateReverseCardPrompt(card, domainRule, userHint='') {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
  Create a REVERSED flashcard that asks for the ORIGINAL FRONT given the ORIGINAL BACK.

  Hard constraints:
  - The new FRONT must be a natural question a student could see on a test.
  - Do NOT write meta-questions about "what question would..." or "given the answer".
  - Do NOT mention "answer" or "question" explicitly.
  - Keep fronts univocal (single correct answer). Keep backs atomic (one idea).
  - Preserve notation; Markdown/LaTeX allowed ($...$ or \\[...\\]).
  - If the original FRONT contains "types of X", "examples of X", or "definition of X", prefer forms like "Y and Z are both examples of what?" or "What is X?".

  ${userHint ? `User hint: ${userHint}` : ''}

  Domain guidance:
  ${domainFragment}

  Return ONLY a JSON object:
  {
    "source": "verbatim snippet (<=160 chars) from the document (prefer original source)",
    "front":  "reversed prompt (no meta language)",
    "back":   "single-idea answer",
    "explanation": "optional"
  }

  ORIGINAL CARD:
  {
    "source": "${(card.source || '').replace(/"/g, '\\"')}",
    "front": "${(card.front || '').replace(/"/g, '\\"')}",
    "back": "${(card.back || '').replace(/"/g, '\\"')}"
  }
  `;
}

function generateNewFromHighlightPrompt(card, userHint, domainRule) {
  const languageInstruction = getLanguageInstruction();
  const domainFragment = (domainRule && domainRule.prompt) ? domainRule.prompt : '';
  const currentDate = new Date();

  // Local context around the anchor to help the model compose the new card
  const fullText = documentInput.value;
  const ctxStart = Math.max(0, card.position.start - 500);
  const ctxEnd   = Math.min(fullText.length, card.position.end + 500);
  const context  = fullText.substring(ctxStart, ctxEnd);

  return `${languageInstruction}You are an expert study coach on ${currentDate}.
Create a NEW flashcard based on the highlighted SOURCE and the EXISTING card shown below.
Use the user's hint strictly to guide what new knowledge to target.

Hard constraints:
- Atomicity: the new BACK must contain a single idea.
- Univocality: the new FRONT must imply a single correct answer.
- Preserve notation; Markdown/LaTeX allowed.
- Do not merely rephrase the existing card; produce a distinct, useful card.
- Prefer fronts that could appear on a test.

User hint: "${userHint || '(no hint provided)'}"

Domain guidance:
${domainFragment}

Return ONLY a JSON object OR a one-element JSON array with keys:
{
  "source": "verbatim snippet (<=160 chars) from the DOCUMENT (prefer the same highlight if appropriate)",
  "front":  "new prompt/question",
  "back":   "new single-idea answer",
  "explanation": "optional"
}

DOCUMENT CONTEXT:
\`\`\`
${context}
\`\`\`

EXISTING CARD:
{
  "source": "${(card.source || '').replace(/"/g, '\\"')}",
  "front": "${(card.front || '').replace(/"/g, '\\"')}",
  "back": "${(card.back || '').replace(/"/g, '\\"')}"
}`;
}

async function handleMakeCardFromSelection() {
  if (!selectedText || !selectedRange) return;

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Generating card...';

    // Use the currently chosen domain rule if set
    const chosen = window.WRITING_RULES[styleSelect?.value] || window.WRITING_RULES['flashcards'];
    const model = getModelForType('flashcard');

    const fullText = documentInput.value;
    const ctxStart = Math.max(0, selectedRange.start - 400);
    const ctxEnd   = Math.min(fullText.length, selectedRange.end + 400);
    const context  = fullText.substring(ctxStart, ctxEnd);

    const prompt = generateSelectionFlashcardPrompt(selectedText, context, chosen);
    const results = await callLLMAPI(prompt, model);

    const arr = Array.isArray(results) ? results : [];
    if (arr.length === 0) {
      alert('No card generated for the selection.');
      return;
    }

    // Normalize and insert as suggestions anchored to the selection range
    arr.forEach(obj => {
      const card = {
        type: 'flashcard',
        source: (typeof obj.source === 'string' && obj.source.length > 0) ? obj.source : selectedText.slice(0, 160),
        front:  (typeof obj.front  === 'string') ? obj.front  : '',
        back:   (typeof obj.back   === 'string') ? obj.back   : '',
        explanation: (typeof obj.explanation === 'string') ? obj.explanation : '',
        position: { start: selectedRange.start, end: selectedRange.end }
      };
      corrections.push(card);
    });

    // Clear user selection so the suggestion highlight is visible
    clearUserSelection();

    // Jump to the last inserted card (or the first if only one)
    currentIndex = corrections.length - 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Card generation failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleRegenerateCard(hint = '', replaceCurrent = true) {
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') return;

  const chosen = window.WRITING_RULES[styleSelect?.value] || window.WRITING_RULES['flashcards'];
  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Re-generating…';

    const model = getModelForType('flashcard'); // your existing model picker
    const prompt = generateRegenerateCardPrompt(card, hint, chosen); // from earlier step
    const results = await callLLMAPI(prompt, model); // or callGeminiAPI

    // Prefer first candidate if an array; accept object otherwise
    const r = Array.isArray(results) ? results[0] : results;
    if (!r || !r.front || !r.back) {
      alert('No usable alternative returned.');
      return;
    }

    const newCard = {
      type: 'flashcard',
      source: typeof r.source === 'string' && r.source.length ? r.source : (card.source || ''),
      front:  r.front,
      back:   r.back,
      explanation: typeof r.explanation === 'string' ? r.explanation : 'Regenerated variant.',
      position: { ...card.position }
    };

    // --- UNDO: save previous card to restore on undo ---
    undoStack.push({
      action: 'regenerate_replace',
      index: currentIndex,
      previous: { ...card }
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    // Replace the current card in place
    corrections[currentIndex] = newCard;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Re-generate failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleSplitCard(userHint = '', useModal = false) {
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') return;

  const chosen = window.WRITING_RULES[styleSelect?.value] || window.WRITING_RULES['flashcards'];
  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Splitting into two…';

    const model = getModelForType('flashcard');
    const prompt = generateSplitCardPrompt(card, chosen);
    let results = await callLLMAPI(prompt, model);

    // Fallback (manual) if the model doesn't return exactly two objects
    if (!Array.isArray(results) || results.length !== 2) {
      const sep = promptUserForSeparator(); // crude fallback
      if (!sep) { loadingOverlay.style.display = 'none'; return; }
      const parts = (card.back || '').split(sep).map(s => s.trim()).filter(Boolean);
      const two = parts.slice(0, 2);
      results = two.map((p, i) => ({
        source: card.source || '',
        front:  i === 0 ? card.front : `${card.front} (part 2)`,
        back:   p,
        explanation: 'Manual split by separator'
      }));
      if (results.length !== 2) {
        alert('Could not split into exactly two cards.');
        return;
      }
    }

    const normalized = results.map(obj => ({
      type: 'flashcard',
      source: (typeof obj.source === 'string' && obj.source.length) ? obj.source : (card.source || ''),
      front:  (typeof obj.front  === 'string') ? obj.front  : '',
      back:   (typeof obj.back   === 'string') ? obj.back   : '',
      explanation: (typeof obj.explanation === 'string') ? obj.explanation : 'Split from combined card.',
      position: { ...card.position }
    }));

    // --- UNDO: record split replacement ---
    undoStack.push({
      action: 'split_replace',
      index: currentIndex,
      previous: { ...card },
      newCards: normalized.map(x => ({ ...x }))
    });
    undoBtn.style.display = 'flex';
    redoStack.length = 0; if (redoBtn) redoBtn.style.display = 'none';

    // Replace current with first, insert second after
    corrections[currentIndex] = normalized[0];
    corrections.splice(currentIndex + 1, 0, normalized[1]);

    updateActiveCorrection();
  } catch (err) {
    console.error(err);
    alert('Split failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleReverseCard(userHint = '', useModal = false) {
  // We assume your "current card" is the active suggestion in corrections[currentIndex]
  const card = corrections[currentIndex];
  if (!card || card.type !== 'flashcard') {
    alert('No flashcard selected to reverse.');
    return;
  }

  const chosen = window.WRITING_RULES[styleSelect?.value] || window.WRITING_RULES['flashcards'] || {};
  const model  = getModelForType('flashcard'); // if you haven’t added flashcard model mapping yet, pick one explicitly

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Reversing…';

    // 1) First attempt from the LLM
    const prompt1 = generateReverseCardPrompt(card, chosen, userHint);
    let result = await callLLMAPI(prompt1, model);

    // If provider returns arrays accidentally, prefer first object
    if (Array.isArray(result)) result = result[0];

    // 2) Validate; if meta or missing, retry once with stronger hint
    if (!result || !result.front || !result.back || looksMetaQuestion(result.front)) {
      const prompt2 = generateReverseCardPrompt(
        card,
        chosen,
        (userHint ? `${userHint}; ` : '') +
        'DO NOT write about "questions" or "answers"; use the pattern “X and Y are examples of what?” when applicable.'
      );
      let second = await callLLMAPI(prompt2, model);
      if (Array.isArray(second)) second = second[0];

      if (second && second.front && second.back && !looksMetaQuestion(second.front)) {
        result = second;
      } else {
        // 3) Heuristic fallback
        result = tryHeuristicReverse(card);
      }
    }

    if (!result || !result.front || !result.back) {
      alert('Reverse failed to produce a useful card.');
      return;
    }

    // Normalize → insert as a NEW suggestion right after the current one (so you can accept/reject)
    const reversed = {
      type: 'flashcard',
      source: (typeof result.source === 'string' && result.source.length) ? result.source : (card.source || ''),
      front:  (typeof result.front  === 'string') ? result.front  : '',
      back:   (typeof result.back   === 'string') ? result.back   : '',
      explanation: (typeof result.explanation === 'string') ? result.explanation : 'Reversed card.',
      position: { ...card.position }
    };

    // --- UNDO payload for "insert candidates" (so you can undo/redo)
    undoStack.push({ action: 'insert_candidates', afterIndex: currentIndex, items: [reversed] });
    if (typeof redoStack !== 'undefined') {
      redoStack.length = 0;
      const redoBtn = document.getElementById('redoBtn');
      if (redoBtn) redoBtn.style.display = 'none';
    }
    if (undoBtn) undoBtn.style.display = 'flex';

    // Insert and focus the new candidate
    corrections.splice(currentIndex + 1, 0, reversed);
    currentIndex = currentIndex + 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('Reverse failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleNewFromHighlight(hint = '') {
  const base = corrections[currentIndex];
  if (!base || base.type !== 'flashcard') {
    alert('No flashcard selected.');
    return;
  }

  const chosen = window.WRITING_RULES[styleSelect?.value] || window.WRITING_RULES['flashcards'] || {};
  const model  = getModelForType('flashcard');

  try {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Creating new card…';

    const prompt = generateNewFromHighlightPrompt(base, hint, chosen);
    let result = await callLLMAPI(prompt, model);

    // Accept a single object or a single-element array
    if (Array.isArray(result)) result = result[0];
    if (!result || !result.front || !result.back) {
      alert('No usable card returned.');
      return;
    }

    const newCard = {
      type: 'flashcard',
      source: (typeof result.source === 'string' && result.source.length) ? result.source : (base.source || ''),
      front:  result.front,
      back:   result.back,
      explanation: (typeof result.explanation === 'string') ? result.explanation : 'New card from highlight.',
      position: { ...base.position }   // anchor to the same highlight
    };

    // Record undo as an insertion of candidates after current
    undoStack.push({ action: 'insert_candidates', afterIndex: currentIndex, items: [newCard] });
    undoBtn.style.display = 'flex';
    if (redoStack) { redoStack.length = 0; if (redoBtn) redoBtn.style.display = 'none'; }

    // Insert after current, and focus the new one
    corrections.splice(currentIndex + 1, 0, newCard);
    currentIndex = currentIndex + 1;
    updateActiveCorrection();

  } catch (err) {
    console.error(err);
    alert('New-from-highlight failed.');
  } finally {
    loadingOverlay.style.display = 'none';
  }
}


function promptUserForSeparator() {
  const s = window.prompt('Model did not return two cards.\nEnter a separator to split the back into two (e.g., ";", "and", " / ").\nLeave blank to cancel.');
  return s && s.trim() ? s.trim() : null;
}

window.WRITING_RULES = {
  // Basic grammar and spelling check
  "grammar": {
    name: "Grammar & Spelling",
    description: "Check for grammatical errors and spelling mistakes",
    type: "grammar"
  },

   // NEW: Flashcards rule
  "flashcards": {
    name: "Flashcards",
    description: "Generate Q/A cards anchored to the source text",
    type: "flashcard"
  },

  "models_ultimateai": {
  // Set your preferred UltimateAI models here (user can override via modal input)
  "grammar":   "gpt-5",
  "style":     "gpt-5",
  "simplify":  "gpt-5",
  "proof":     "claude-4-opus",
  "flashcard": "gpt-5" // consider changing to claude-4-opus	
  },

  // Model specifications for different operations
  "models": {
    "grammar": "gemini-2.5-flash-preview-05-20",
    "style": "gemini-2.5-flash-preview-05-20", 
    "simplify": "gemini-2.5-pro-preview-06-05",
    "proof": "gemini-2.5-pro-preview-06-05",
    "flashcard": "gemini-2.5-pro-preview-06-05"          // NEW
  },
  "models_free": {
    "grammar": "gemini-2.5-flash-preview-05-20",
    "style": "gemini-2.5-flash-preview-05-20", 
    "simplify": "gemini-2.5-flash-preview-05-20",
    "proof": "gemini-2.5-flash-preview-05-20",
    "flashcard": "gemini-2.5-flash-preview-05-20"         // NEW
  }
};

// Initial setup
document.addEventListener('DOMContentLoaded', async () => {
  // Check for API key
  checkApiKey();

  // Restore previous choice if set
  const savedProvider = getStoredProvider();
  if (providerSelect) providerSelect.value = savedProvider;
  toggleProviderFields(savedProvider);
  updateProviderLabelFromStorage();

  if (ultimateModelInput) {
    ultimateModelInput.value = localStorage.getItem('ultimateModel') || ''; // don't auto-fill model
  }

  // Export prefs defaults and load
  if (exportStyleSelect) {
    exportStyleSelect.value = localStorage.getItem('exportStyle') || 'neuracache';
    exportStyleSelect.addEventListener('change', () => {
      localStorage.setItem('exportStyle', exportStyleSelect.value);
      updateFlashcardsOutput();
    });
  }
  if (includeSourceCheckbox) {
    includeSourceCheckbox.checked = JSON.parse(localStorage.getItem('exportIncludeSource') || 'false');
    includeSourceCheckbox.addEventListener('change', () => {
      localStorage.setItem('exportIncludeSource', includeSourceCheckbox.checked);
      updateFlashcardsOutput();
    });
  }
  
  loadRules();

  // --- Export settings defaults (stop autofill; use placeholders only) ---
  includeMetadataCheckbox.checked = JSON.parse(localStorage.getItem('exportIncludeMetadata') || 'false');
  generateTagsCheckbox.checked    = JSON.parse(localStorage.getItem('exportGenerateTags')   || 'false');

  metaAuthorInput.value = '';
  metaDeckInput.value   = '';
  metaAuthorInput.placeholder = localStorage.getItem('exportAuthor') || 'wikipedia.org';
  metaDeckInput.placeholder   = localStorage.getItem('exportDeck')   || 'All Cards';

  metadataTemplate.value          = localStorage.getItem('metadataTemplate') || metadataTemplate.value;
  createdAtISO                    = localStorage.getItem('exportCreatedAt') || '';

  includeMetadataCheckbox.addEventListener('change', () => {
    localStorage.setItem('exportIncludeMetadata', includeMetadataCheckbox.checked);
    updateFlashcardsOutput();
  });
  generateTagsCheckbox.addEventListener('change', () => {
    localStorage.setItem('exportGenerateTags', generateTagsCheckbox.checked);
    updateFlashcardsOutput();
  });

  freeModelsCheckbox.checked = JSON.parse(localStorage.getItem('useFreeModels') || 'false');
  languageSelect.value       = localStorage.getItem('languagePref') || 'en-US';
  styleSelect.value          = localStorage.getItem('stylePref')    || 'literary_nonfiction';
  
  depthSelect.value = localStorage.getItem('flashcardDepth') || 'medium';
  depthSelect.addEventListener('change', () =>
    localStorage.setItem('flashcardDepth', depthSelect.value)
  );

  freeModelsCheckbox.addEventListener('change', () =>
    localStorage.setItem('useFreeModels', freeModelsCheckbox.checked)
  );
  languageSelect.addEventListener('change', () =>
    localStorage.setItem('languagePref', languageSelect.value)
  );
  styleSelect.addEventListener('change', () =>
    localStorage.setItem('stylePref', styleSelect.value)
  );
  
  documentInput.value = `\\documentclass{article}
  \\begin{document}

  \\title{History of Deep Learning}
  \\author{Wikipedia}
  \\maketitle

  There are two types of artificial neural network (ANN): feedforward neural network (FNN) or multilayer perceptron (MLP) and recurrent neural networks (RNN). RNNs have cycles in their connectivity structure, FNNs don't. In the 1920s, Wilhelm Lenz and Ernst Ising created the Ising model which is essentially a non-learning RNN architecture consisting of neuron-like threshold elements. In 1972, Shun'ichi Amari made this architecture adaptive. His learning RNN was republished by John Hopfield in 1982. Other early recurrent neural networks were published by Kaoru Nakano in 1971. Already in 1948, Alan Turing produced work on "Intelligent Machinery" containing ideas related to artificial evolution and learning RNNs.

  Frank Rosenblatt (1958) proposed the perceptron, an MLP with 3 layers: an input layer, a hidden layer with randomized weights that did not learn, and an output layer. He later published a 1962 book that also introduced variants and computer experiments, including a version with four-layer perceptrons "with adaptive preterminal networks" where the last two layers have learned weights. The book cites an earlier network by R. D. Joseph (1960) "functionally equivalent to a variation of" this four-layer system. Should Joseph therefore be considered the originator of proper adaptive multilayer perceptrons with learning hidden units? Unfortunately, the learning algorithm was not a functional one, and fell into oblivion.
  \\end{document}`;
  
  adjustTextareaHeight();
  updateHighlightOverlay();
  syncSidebarPadding();

  // Sync scroll
  documentInput.addEventListener('scroll', () => {
    highlightOverlay.scrollTop = documentInput.scrollTop;
    highlightOverlay.scrollLeft = documentInput.scrollLeft;
  });

  documentInput.addEventListener('input', () => {
      // If user types, clear corrections
      if (corrections.length > 0) {
          resetState();
      }
      updateHighlightOverlay();
    // Auto-size only when overlay is off
      if (!(corrections.length > 0) && !selectionMode) {
        adjustTextareaHeight();
      } 
  });
  
  // Handle text selection
  documentInput.addEventListener('mouseup', handleTextSelection);
  documentInput.addEventListener('keyup', handleTextSelection);
    updateNavigation();

  // Observe left toolbar to keep padding in sync as buttons appear/disappear
  const headerElForObserver = document.querySelector('.header');
  if (headerElForObserver) {
    const mo = new MutationObserver(syncSidebarPadding);
    mo.observe(headerElForObserver, { attributes: true, childList: true, subtree: true });
  }
  window.addEventListener('resize', syncSidebarPadding);
});

// Event Listeners
prevBtn.addEventListener('click', () => navigateCorrections(-1));
nextBtn.addEventListener('click', () => navigateCorrections(1));
popoverAcceptBtn.addEventListener('click', () => acceptCorrection(currentIndex));
popoverRejectBtn.addEventListener('click', () => rejectCorrection(currentIndex));
simplificationModalClose.addEventListener('click', closeSimplificationModal);
simplificationOverlay.addEventListener('click', closeSimplificationModal);
summaryClose.addEventListener('click', closeSummaryModal);
modalOverlay.addEventListener('click', closeSummaryModal);
apiKeySubmit.addEventListener('click', saveApiKey);
aboutClose.addEventListener('click', closeAboutModal);
aboutOverlay.addEventListener('click', closeAboutModal);
fileClose.addEventListener('click', closeFileModal);
fileOverlay.addEventListener('click', closeFileModal);
fileSelectBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', handleFileSelect);
simplifyBtn.addEventListener('click', handleSimplification);
proofBtn.addEventListener('click', handleProofCheck);
copyBtn.addEventListener('click', () => {
  // This line grabs the ENTIRE text from the editor, regardless of selection
  navigator.clipboard.writeText(documentInput.value).then(() => {
    const copyIcon = copyBtn.querySelector('.icon-copy');
    const checkIcon = copyBtn.querySelector('.icon-check');

    // Swap icons for feedback
    copyIcon.style.display = 'none';
    checkIcon.style.display = 'inline-block';

    // Swap back after 2 seconds
    setTimeout(() => {
      copyIcon.style.display = 'inline-block';
      checkIcon.style.display = 'none';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy text: ', err);
    alert('Failed to copy text.');
  });
});

// This listener is for the "Download" icon button
downloadBtn.addEventListener('click', () => {
  // This line also grabs the ENTIRE text from the editor
  const text = documentInput.value;
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'document.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Drag and drop handlers
dropZone.addEventListener('dragover', handleDragOver);
dropZone.addEventListener('dragleave', handleDragLeave);
dropZone.addEventListener('drop', handleDrop);

document.addEventListener('keydown', (e) => {
  // If any modal open, ignore global shortcuts
  const anyModalOpen =
    (actionModal && actionModal.classList.contains('visible')) ||
    (simplificationModal && simplificationModal.classList.contains('visible')) ||
    (summaryModal && summaryModal.classList.contains('visible')) ||
    (aboutModal && aboutModal.classList.contains('visible')) ||
    (fileModal && fileModal.classList.contains('visible')) ||
    (apiKeyModal && apiKeyModal.style.display === 'block');
  if (anyModalOpen) return;

  // While the user is selecting text, ignore accept/reject keystrokes
  if (selectionMode) {
    if (['Enter', 'Backspace', 'Delete'].includes(e.key)) {
      e.preventDefault();
      return;
    }
  }
  
  // Check if we're editing the corrected text
  if (document.activeElement === popoverCorrected || document.activeElement === popoverOriginal) {
  // Accept current card with Enter (don’t insert a newline)
  if ((e.key === 'Enter') && (e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    acceptCorrection(currentIndex);
    return;
  }
  // Fast reject while editing: Cmd/Ctrl+Backspace or Cmd/Ctrl+Delete
  if ((e.key === 'Backspace' || e.key === 'Delete') && (e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    rejectCorrection(currentIndex);
    return;
  }
  // Optional: Esc to leave the field without closing the popover
  if (e.key === 'Escape') {
    e.preventDefault();
    if (document.activeElement) document.activeElement.blur();
    return;
  }
  // For all other keys, keep typing normal and do NOT trigger global shortcuts
  return;
  }


  // Handle Undo (⌘/Ctrl + Z) for our action stack
  if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {
    if (undoStack.length > 0) {
      e.preventDefault();   // stop the textarea's native undo
      handleUndo();
      return;
    }
    // If no app-level undo, fall through to native behavior
  }

  // Redo (Cmd/Ctrl+Shift+Z)
  if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'z') {
    if (redoStack.length > 0) {
      e.preventDefault();
      handleRedo();
      return;
    }
  }

  // Only when a suggestion is active
  if (corrections.length > 0 && currentIndex > -1) {
    const k = e.key.toLowerCase();

    // Prevent browser Save dialog when we want Split modal
    if ((e.ctrlKey || e.metaKey) && k === 's') {
      e.preventDefault();
      openActionModal('split');
      return;
    }

    // Split (s)
    if (!e.ctrlKey && !e.metaKey && k === 's') {
      e.preventDefault();
      handleSplitCard('');
      return;
    }

    // Reverse (r) — Ctrl/⌘ for modal
    if ((e.ctrlKey || e.metaKey) && k === 'r') {
      e.preventDefault();
      openActionModal('reverse');
      return;
    }
    if (!e.ctrlKey && !e.metaKey && k === 'r') {
      e.preventDefault();
      handleReverseCard('');
      return;
    }

    // Regenerate (a) always opens modal
    if (!e.ctrlKey && !e.metaKey && k === 'a') {
      e.preventDefault();
      openActionModal('regenerate');
      return;
    }

    // New-from-highlight (n) — always opens modal; avoid Ctrl/⌘+N (browser new window)
    if (!e.ctrlKey && !e.metaKey && k === 'n') {
      e.preventDefault();
      openActionModal('new_from_highlight');
      return;
    }
  }

  if (e.key === 'ArrowRight') {
    e.preventDefault();
    nextBtn.click();
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    prevBtn.click();
  } else if (e.key === 'Enter') {
     e.preventDefault();
     acceptCorrection(currentIndex);
  } else if (e.key === 'Backspace' || e.key === 'Delete') {
    if (corrections.length > 0) {        // only lock keys while corrections are active
        e.preventDefault();
      rejectCorrection(currentIndex);
    }
  } else if (e.key === 'Escape') {
      e.preventDefault();
      hidePopover();
      closeSimplificationModal();
      closeAboutModal();
      closeFileModal();
  }
});


document.addEventListener('click', (e) => {
    // GUARD CLAUSE: If we are in correction mode, do not allow
    // a "click away" to hide the popover. The popover must persist.
    if (corrections.length > 0) {
        return;
    }

    // This logic now only runs when NOT in correction mode.
    if (currentIndex > -1 && !suggestionPopover.contains(e.target) && !e.target.closest('.suggestion')) {
        hidePopover();
        currentIndex = -1; 
        updateNavigation();
    }
});

function checkApiKey() {
  const provider = getStoredProvider();
  const hasGemini = typeof window.GEMINI !== 'undefined' && !!window.GEMINI;
  const storedGemini = localStorage.getItem('geminiKey') || '';
  const storedUltimate = localStorage.getItem('ultimateKey') || '';

  if (providerSelect) providerSelect.value = provider;
  toggleProviderFields(provider);

  if (provider === 'gemini') {
    if (!hasGemini && !storedGemini) {
      apiKeyModal.style.display = 'block';
      loadingOverlay.style.display = 'flex';
      loadingOverlay.style.background = 'rgba(0, 0, 0, 0.5)';
      loadingText.style.display = 'none';
    }
  } else {
    if (!storedUltimate) {
      apiKeyModal.style.display = 'block';
      loadingOverlay.style.display = 'flex';
      loadingOverlay.style.background = 'rgba(0, 0, 0, 0.5)';
      loadingText.style.display = 'none';
    }
  }
}

function saveApiKey() {
  const provider = providerSelect ? providerSelect.value : 'gemini';
  localStorage.setItem('provider', provider);

  if (provider === 'gemini') {
    const key = apiKeyInput.value.trim();
    if (key) {
      window.GEMINI = key;
      localStorage.setItem('geminiKey', key);
    }
  } else {
    const uKey = (document.getElementById('ultimateKeyInput').value || '').trim();
    const uModel = (document.getElementById('ultimateModelInput').value || '').trim();
    if (uKey) localStorage.setItem('ultimateKey', uKey);
    if (uModel) localStorage.setItem('ultimateModel', uModel);
  }

  apiKeyModal.style.display = 'none';
  loadingOverlay.style.display = 'none';
  loadingOverlay.style.background = 'rgba(255, 255, 248, 0.9)';
  loadingText.style.display = 'block';
}

  function loadRules() {
    const selectors = [ ruleSelect, styleSelect ];
    
    selectors.forEach(selector => {
      if (!selector) return;
      selector.innerHTML = '';
      
      const isStyle = selector.id === 'styleSelect';
      
      Object.entries(window.WRITING_RULES)
        .filter(([key, rule]) => {
          if (!rule.name) return false;           // must have a name
          if (isStyle) {
            // Show only flashcard-type entries in the domain dropdown
            return typeof rule.prompt === 'string' && rule.type === 'flashcard';
          } else {
            // in the main rules dropdown, skip any model‐config keys
            return key !== 'models' && key !== 'models_free';
          }
        })
        .forEach(([key, rule]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = rule.name;
          selector.appendChild(option);
        });
    });
    
    // pick the first style rule as the default
    const firstStyle = Object.entries(window.WRITING_RULES)
      .find(([_k, r]) => typeof r.prompt === 'string');
    if (firstStyle) {
      styleSelect.value = firstStyle[0];
    }
  }

function resetState() {
    corrections = [];
    currentIndex = -1;
    documentInput.readOnly = false;
    undoStack = [];
    undoBtn.style.display = 'none';
    documentInput.classList.remove('locked'); // <-- UNLOCK MOUSE EVENTS
    hidePopover();
    updateHighlightOverlay();
    updateNavigation();
}

function handleTextSelection() {
  const focused = document.activeElement === documentInput;
  const hasSelection = focused && (documentInput.selectionStart !== documentInput.selectionEnd);

  if (hasSelection) {
    selectionMode = true;
    selectedText = documentInput.value.substring(documentInput.selectionStart, documentInput.selectionEnd);
    selectedRange = { start: documentInput.selectionStart, end: documentInput.selectionEnd };
    // Temporarily hide the accept/reject popover while the user is selecting
    hidePopover();
  } else {
    selectionMode = false;
    selectedText = '';
    selectedRange = null;
    // Restore the popover for the current card if we are in approval mode
    if (corrections.length > 0 && currentIndex > -1) {
      // This will re-show the popover for the active chip
      updateActiveCorrection();
    }
  }

  updateHighlightOverlay();
  updateNavigation();
}

function clearUserSelection() {
    // 1. Collapse the logical selection in the textarea
    documentInput.setSelectionRange(documentInput.selectionStart, documentInput.selectionStart);

    // 2. Reset our application's selection state variables
    selectionMode = false;
    selectedText = '';
    selectedRange = null;

    // 3. Force the UI to update based on the now-cleared state
    updateHighlightOverlay();
    updateNavigation();
}

function getLanguageInstruction() {
    const languageSelect = document.getElementById('languageSelect');
    const selectedOption = languageSelect.options[languageSelect.selectedIndex];
    const languageValue = selectedOption.value;
    const languageText = selectedOption.text;

    if (languageValue === 'other') {
        return '';
    }
    return `The primary language of this document is ${languageText}.\n\n`;
}

function getModelForType(type) {
  const provider = getStoredProvider();
  if (provider === 'ultimateai') {
    // If user typed a specific UltimateAI model, prefer it for flashcards
    if (type === 'flashcard') {
      const userModel = localStorage.getItem('ultimateModel') || (ultimateModelInput ? ultimateModelInput.value.trim() : '');
      if (userModel) return userModel;
    }
    const m = (window.WRITING_RULES.models_ultimateai || {})[type];
    return m || 'gpt-4o-mini';
  }

  // Gemini path
  const useFreeModels = document.getElementById('freeModelsCheckbox').checked;
  const rulesRoot = window.WRITING_RULES || {};
  const models = useFreeModels ? rulesRoot.models_free : rulesRoot.models;
  return (models && models[type]) ? models[type] : 'gemini-2.0-flash';
}

function extractLatexContent(text) {
  // Check if it's a LaTeX document
  if (!text.includes('\\begin{document}')) {
    return text;
  }
  
  const beginMatch = text.indexOf('\\begin{document}');
  const endMatch = text.indexOf('\\end{document}');
  
  if (beginMatch !== -1 && endMatch !== -1) {
    // Extract content between \begin{document} and \end{document}
    return text.substring(beginMatch + '\\begin{document}'.length, endMatch).trim();
  } else if (beginMatch !== -1) {
    // Only \begin{document} found, take everything after it
    return text.substring(beginMatch + '\\begin{document}'.length).trim();
  }
  
  return text;
}

function handleUndo() {
  if (undoStack.length === 0) return;
  const last = undoStack.pop();

  // Card accepts (remove from bin; restore suggestion)
  if (last.action === 'accept_card') {
    const { index, correction, card } = last;
    const i = acceptedFlashcards.findIndex(c => c.front === card.front && c.back === card.back);
    if (i !== -1) acceptedFlashcards.splice(i, 1);
    updateFlashcardsOutput();
    corrections.splice(index, 0, correction);
    currentIndex = index;

    // Push redo payload
    redoStack.push({ action: 'accept_card', index, correction, card });
    const redoBtn = document.getElementById('redoBtn');
    if (redoBtn) redoBtn.style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Card rejects (reinsert suggestion)
  if (last.action === 'reject_card') {
    const { index, correction } = last;
    corrections.splice(index, 0, correction);
    currentIndex = index;

    redoStack.push({ action: 'reject_card', index });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Regenerate replace (restore previous)
  if (last.action === 'regenerate_replace') {
    const { index, previous, nextCard } = last;
    corrections[index] = previous;
    currentIndex = index;

    redoStack.push({ action: 'regenerate_replace', index, previous, nextCard });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Insert candidates (split/reverse) — remove them
  if (last.action === 'insert_candidates') {
    const { afterIndex, items } = last;
    corrections.splice(afterIndex + 1, items.length);
    currentIndex = afterIndex;

    redoStack.push({ action: 'insert_candidates', afterIndex, items });
    document.getElementById('redoBtn').style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Split replace — restore original and remove the two new cards
  if (last.action === 'split_replace') {
    const { index, previous, newCards } = last;
    // Remove the two new cards and put the original back
    corrections.splice(index, 2, previous);
    currentIndex = index;

    // Redo payload: re-apply the split replacement
    redoStack.push({ action: 'split_replace', index, previous, newCards });
    const rb = document.getElementById('redoBtn'); if (rb) rb.style.display = 'flex';

    updateActiveCorrection();
    if (undoStack.length === 0) undoBtn.style.display = 'none';
    return;
  }

  // Legacy text edit (grammar/style accept)
  documentInput.value = last.textBefore;
  corrections.splice(last.index, 0, last.correction);
  if (last.lengthDiff) {
    for (let i = last.index + 1; i < corrections.length; i++) {
      corrections[i].position.start -= last.lengthDiff;
      corrections[i].position.end   -= last.lengthDiff;
    }
  }
  currentIndex = last.index;

  // Prepare redo payload for legacy edit
  const editedText = popoverCorrected.textContent || '';
  redoStack.push({ action: 'legacy_text', index: last.index, correction: last.correction, editedText, _undoPayload: last });
  document.getElementById('redoBtn').style.display = 'flex';

  updateActiveCorrection();
  if (undoStack.length === 0) undoBtn.style.display = 'none';
}


function handleRedo() {
  if (redoStack.length === 0) return;
  const next = redoStack.pop();

  // Mirror the forward actions you support.
  if (next.action === 'accept_card') {
    // Apply accept again
    const { index, correction, card } = next;
    // Remove the suggestion at index (if it exists at index; else find it)
    const idx = (index >= 0 && index < corrections.length && corrections[index] === correction)
      ? index
      : corrections.findIndex(c => c === correction);
    if (idx !== -1) {
      acceptedFlashcards.push({ front: card.front, back: card.back });
      updateFlashcardsOutput();
      corrections.splice(idx, 1);
      currentIndex = Math.min(idx, corrections.length - 1);
      undoStack.push({ action: 'accept_card', correction, index: idx, card, textBefore: documentInput.value });
      undoBtn.style.display = 'flex';
    }
  } else if (next.action === 'reject_card') {
    // Re-apply reject (remove suggestion again)
    const { index } = next;
    if (index >= 0 && index < corrections.length) {
      const removed = corrections.splice(index, 1)[0];
      undoStack.push({ action: 'reject_card', correction: removed, index, textBefore: documentInput.value });
      undoBtn.style.display = 'flex';
      currentIndex = Math.min(index, corrections.length - 1);
    }
  } else if (next.action === 'regenerate_replace') {
    // Re-apply replacement (use 'next' card)
    const { index, previous, nextCard } = next;
    const prev = corrections[index];
    corrections[index] = nextCard;
    undoStack.push({ action: 'regenerate_replace', index, previous: prev, nextCard });
    undoBtn.style.display = 'flex';
    currentIndex = index;
  } else if (next.action === 'insert_candidates') {
    // Reinsert newly created suggestions (split/reverse)
    const { afterIndex, items } = next;
    corrections.splice(afterIndex + 1, 0, ...items);
    undoStack.push({ action: 'insert_candidates', afterIndex, items });
    undoBtn.style.display = 'flex';
    currentIndex = afterIndex + 1;
  } else if (next.action === 'split_replace') {
    const { index, previous, newCards } = next;
    const prevAtIndex = corrections[index];
    // Apply split again
    corrections.splice(index, 1, newCards[0]);
    corrections.splice(index + 1, 0, newCards[1]);

    undoStack.push({ action: 'split_replace', index, previous: prevAtIndex, newCards });
    undoBtn.style.display = 'flex';
    currentIndex = index;
   } else {
    // Legacy text edit redo (grammar/style)
    const { index, correction, editedText } = next;
    let currentText = documentInput.value;
    const len = correction.position.end - correction.position.start;
    documentInput.value = currentText.substring(0, correction.position.start) + editedText +
                          currentText.substring(correction.position.start + len);
    undoStack.push(next._undoPayload); // symmetric payload saved when pushing redo
    undoBtn.style.display = 'flex';
    currentIndex = Math.min(index, corrections.length - 1);
  }

  if (redoStack.length === 0) {
    const redoBtn = document.getElementById('redoBtn');
    if (redoBtn) redoBtn.style.display = 'none';
  }
  updateActiveCorrection();
}

function splitTextIntoChunks(text, maxChunkSize = 30000) {
  const chunks = [];
  const paragraphs = text.split(/\n\n+/);
  let currentChunk = '';
  
  for (const paragraph of paragraphs) {
    if (currentChunk.length + paragraph.length + 2 > maxChunkSize && currentChunk.length > 0) {
      chunks.push(currentChunk.trim());
      currentChunk = paragraph;
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }
  
  console.log(`Split text into ${chunks.length} chunks. Sizes:`, chunks.map(c => c.length));
  
  return chunks;
}

function generatePrompt(text, rule) {
 if (rule.type === 'flashcard') {
    const languageInstruction = getLanguageInstruction();
    const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
    const depthInstruction = {
      shallow: `Generate only high-yield cards. Target ~1 card per 300–500 words (or 3–5 paragraphs).`,
      medium:  `Generate 1–3 cards per paragraph (~1 per 150–250 words).`,
      complete:`Generate cards for nearly every line of content: each definition, equation, step, bullet, and claim gets at least one card. If sentences contain multiple ideas, create multiple cards.`
    }[depth] || '';

    // rule.prompt is our DOMAIN fragment from styles.js
    const domainFragment = (rule.prompt || '');

    const currentDate = new Date();
    return `${languageInstruction}You are an expert study coach on ${currentDate}.
    Read the DOCUMENT and output ONLY a JSON array of flashcard objects in order of appearance.
    Atomicity: each "back" expresses exactly one idea.
    Univocality: each "front" has a single correct answer.
    Anchoring: include a "source" snippet (<=160 chars) copied verbatim from the document that motivates the card.
    Notation: you may use Markdown and LaTeX (inline $...$ or display \\[ ... \\]); preserve original symbols/notation. Do not wrap answers in triple backticks.
    No meta commentary. No markdown outside of the Q/A text itself.

    ${depthInstruction}

    Domain guidance:
    ${domainFragment}

    JSON schema (strict):
    [
      {
        "source": "verbatim snippet from the document (<=160 chars, must exist in the text)",
        "front": "short question/prompt; single-answered",
        "back": "concise but complete answer; one idea; may include LaTeX",
        "explanation": "optional: why this card matters (short)"
      },
      ...
    ]

    DOCUMENT:
    \`\`\`
    ${text}
    \`\`\`
    `;
      }
  if (rule.type === 'grammar') {
    console.log(`Grammar`);
    const languageInstruction = getLanguageInstruction();
    const currentDate = new Date();
    return `${languageInstruction}You are an elite editor on ${currentDate}. Analyze the following document for grammatical errors, typos, and spelling mistakes. Return ONLY a JSON array of correction objects. Important: Return the list of corrections in the order they appear in the document. DOUBLE CHECK THAT SUGGESTIONS YOU MAKE ACTUALLY REQUIRE A CORRECTION - NEVER SUGGEST 'No change needed' OR SIMILAR!

Each object must have these exact keys:
- "original": The exact text snippet from the document to be replaced. Be specific enough to be unique.
- "corrected": The corrected version of the text.
- "explanation": A brief, clear reason for the change (e.g., "Grammar: Subject-verb agreement.").
- "type": Must be "grammar".

Focus only on clear errors which are unambiguous. DO NOT suggest em dashes or other changes to hyphenation or dash offsets. Follow University of Chicago style guidelines. Do not suggest stylistic changes; the user has a style editor who handles those corrections. Do not suggest changes for LaTeX commands (like \\documentclass), including opening or closing brackets, and do not correct single vs. double spaces.  Note that the text may be latex, so Latex-style quotation marks (double accent grave, or double apostrophe), or slash before dollar signs or percentages, are not errors. IMPORTANT: The output MUST be a valid JSON array. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).
Return an empty array [] if no errors are found.  

Document to analyze:
\`\`\`
${text}
\`\`\`
`;
  } else {
    console.log(`Style: ${rule.prompt}`);
    const languageInstruction = getLanguageInstruction();
    const currentDate = new Date();
    return `${rule.prompt} ${languageInstruction} It is ${currentDate}.

Return ONLY a JSON array of style suggestion objects. Important: Return the list of corrections in the order they appear in the document. Each object must have these exact keys:
- "original": The exact text snippet from the document to be replaced. THIS SHOULD BE EXACT. We may use LaTeX slash breaks for $ or %, and use extra \\ to avoid escapes.
- "corrected": The improved version of the text.
- "explanation": A brief, clear reason for the change.
- "type": Must be "style".

Do not check grammar or spelling. Do not suggest changes for LaTeX commands. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).
Return an empty array [] if no improvements are needed.

Document to analyze:
\`\`\`
${text}
\`\`\`
`;
  }
}


function generateSimplificationPrompt(text, context) {
  const languageInstruction = getLanguageInstruction();
  const currentDate = new Date();
  const model = getModelForType('simplify');
  return `${languageInstruction}You are an elite editor on ${currentDate}. The following text may come from an academic article (in which case act like an editor for academically precise content where you still care about good, easy-to-read writing), or general writing. Simplify the following text passage. Provide exactly THREE versions:

1. Same Length: Use simpler words and shorter sentences, but keep approximately the same length. Do NOT replace technical terms if they have precise definitions, but do make the writing snappier and less unwieldy, like a great editor would.
2. Moderately Shorter: Do the same as in step 1, but reduce length by about 30% while maintaining all key information
3. Much Shorter: Do the same as in step 2, but reduce length by 50-60%, keeping only essential information

IMPORTANT: Never change mathematical notation, technical terminology, formulas, or proper nouns. Only simplify the language structure and non-technical vocabulary. Do not use markdown in your response. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).

Return as JSON:
{
  "same_length": "simplified text here",
  "moderate": "shorter simplified text here",
  "concise": "much shorter text here"
}

Text to simplify:
"${text}"

Context (for reference only):
${context}
`;
}

function generateProofCheckPrompt(proofText, fullDocument) {
  const languageInstruction = getLanguageInstruction();
  const currentDate = new Date();
  const model = getModelForType('proof');
  return `${languageInstruction}Act like a very well-trained technical graduate student on ${currentDate}. Check the validity of the following mathematical proof or logical argument. Analyze it for:
- Logical errors or gaps in reasoning
- Missing steps or assumptions
- Incorrect applications of theorems or definitions
- Unclear or ambiguous statements
Be sure to go through the precise assumptions, the precise conclusions, and the logical steps between them, checking every step for accuracy. If you believe there is an error or omission, be as precise as possible, and write all mathematics in LaTeX. Do not use markdown as a bold. IMPORTANT: The output MUST be a valid JSON object. All backslashes \\ in the text, such as in LaTeX commands like \\cite, must be escaped with a second backslash (e.g., \\\\cite).

Return a JSON object:
{
  "is_valid": true/false,
  "issues": ["List of specific problems found"],
  "questions": ["List of clarifying questions about unclear parts"],
  "suggestions": ["List of specific improvements"],
  "overall": "Brief overall assessment"
}

Proof to check:
"${proofText}"

Full document context:
${fullDocument}
`;
}

function toggleProviderFields(provider) {
  if (!geminiFields || !ultimateFields) return;
  if (provider === 'ultimateai') {
    geminiFields.style.display = 'none';
    ultimateFields.style.display = 'block';
    // The "Use free models" toggle is Gemini-specific; hide if not Gemini
    const freeBox = document.getElementById('freeModelsCheckbox');
    if (freeBox) freeBox.parentElement.style.display = 'none';
  } else {
    geminiFields.style.display = 'block';
    ultimateFields.style.display = 'none';
    const freeBox = document.getElementById('freeModelsCheckbox');
    if (freeBox) freeBox.parentElement.style.display = 'flex';
  }
}
if (providerSelect) {
  providerSelect.addEventListener('change', () => {
    localStorage.setItem('provider', providerSelect.value);
    toggleProviderFields(providerSelect.value);
  });
}

function openActionModal(kind, preset='') {
  pendingAction = kind;
  actionTitle.textContent = kind === 'split' ? 'Split Card (Optional Hint)'
                        : kind === 'reverse' ? 'Reverse Card (Optional Hint)'
                        : 'Regenerate Card';
  actionHintArea.value = preset || '';
  actionModal.classList.add('visible');
  actionOverlay.classList.add('visible');
  setTimeout(() => actionHintArea.focus(), 0);
}
function closeActionModal() {
  pendingAction = null;
  actionModal.classList.remove('visible');
  actionOverlay.classList.remove('visible');
}

function buildMetadataBlock(template, author, deck, createdISO, modifiedISO, tags) {
  // {{tags}} expands to multiple "  - tag" lines; others are simple substitutions.
  const tagLines = (tags || []).map(t => `  - ${t}`).join('\n');
  return template
    .replace(/{{\s*author\s*}}/gi, author || '')
    .replace(/{{\s*deck\s*}}/gi, deck || '')
    .replace(/{{\s*created\s*}}/gi, createdISO || '')
    .replace(/{{\s*modified\s*}}/gi, modifiedISO || '')
    .replace(/{{\s*tags\s*}}/gi, tagLines);
}

if (actionClose)   actionClose.addEventListener('click', closeActionModal);
if (actionCancel)  actionCancel.addEventListener('click', closeActionModal);
if (actionOverlay) actionOverlay.addEventListener('click', closeActionModal);

// Submit
if (actionSubmit) actionSubmit.addEventListener('click', () => {
  const hint = (actionHintArea.value || '').trim();
  if (pendingAction === 'regenerate') handleRegenerateCard(hint, /*replaceCurrent=*/true);
  if (pendingAction === 'split')      handleSplitCard(hint, /*useModal=*/true);
  if (pendingAction === 'reverse')    handleReverseCard(hint, /*useModal=*/true);
  if (pendingAction === 'new_from_highlight') handleNewFromHighlight((actionHintArea.value || '').trim());
  closeActionModal();
});

// Buttons (Ctrl/⌘ opens modal; normal click immediate)
if (splitBtn) splitBtn.addEventListener('click', (e) => {
  (e.ctrlKey || e.metaKey) ? openActionModal('split') : handleSplitCard('');
});
if (reverseBtn) reverseBtn.addEventListener('click', (e) => {
  (e.ctrlKey || e.metaKey) ? openActionModal('reverse') : handleReverseCard('');
});
if (regenBtn) regenBtn.addEventListener('click', () => openActionModal('regenerate'));
if (newFromHighlightBtn) newFromHighlightBtn.addEventListener('click', () => openActionModal('new_from_highlight'));

if (downloadFlashcardsMDBtn) downloadFlashcardsMDBtn.addEventListener('click', async () => {
  const text = await renderExportAsync();      // async (see section 2)
  const blob = new Blob([text || ''], { type: 'text/markdown' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'flashcards.md';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

if (exportSettingsBtn) exportSettingsBtn.addEventListener('click', () => {
  exportModal.classList.add('visible');
  exportOverlay.classList.add('visible');
});
if (exportClose)  exportClose.addEventListener('click', closeExportModal);
if (exportOverlay) exportOverlay.addEventListener('click', closeExportModal);

function closeExportModal() {
  exportModal.classList.remove('visible');
  exportOverlay.classList.remove('visible');
}

if (exportSaveBtn) exportSaveBtn.addEventListener('click', () => {
  localStorage.setItem('exportAuthor', metaAuthorInput.value.trim());
  localStorage.setItem('exportDeck',   metaDeckInput.value.trim());
  localStorage.setItem('metadataTemplate', metadataTemplate.value);
  closeExportModal();
  updateFlashcardsOutput();
});

[metaAuthorInput, metaDeckInput, metadataTemplate].forEach(el => {
  el && el.addEventListener('input', () => { /* live preview if desired */ });
});


// Temporary alias until provider switch lands
// async function callLLMAPI(prompt, model, retryCount = 0) {
//  return callGeminiAPI(prompt, model, retryCount);
// }

async function callLLMAPI(prompt, model, retryCount = 0) {
  const provider = localStorage.getItem('provider') || 'gemini';

  if (provider === 'ultimateai') {
    // --- UltimateAI (OpenAI-style chat completions) ---
    const key = localStorage.getItem('ultimateKey') || (ultimateKeyInput ? ultimateKeyInput.value.trim() : '');
    if (!key) throw new Error('UltimateAI key missing.');

    const API_URL = 'https://smart.ultimateai.org/v1/chat/completions';
    const payload = {
      model: model,
      messages: [
        { role: 'system', content: 'You are a precise assistant. Return ONLY valid JSON.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.2
      // Avoid response_format forcing objects because we often want arrays
    };

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err.error?.message || `UltimateAI API error ${response.status}`);
      }
      const data = await response.json();
      const content = data?.choices?.[0]?.message?.content;
      if (!content) throw new Error('UltimateAI response missing content.');
      const parsed = parseJSONLoose(content);
      if (parsed !== null) return parsed;
      throw new Error('Failed to parse any valid JSON from the UltimateAI response.');
    } catch (e) {
      if (retryCount === 0) {
        console.log('UltimateAI error, retrying once…', e.message);
        await new Promise(r => setTimeout(r, 2000));
        return callLLMAPI(prompt, model, 1);
      }
      throw e;
    }
  }

  // --- Gemini path (unchanged behavior) ---
  let gkey = window.GEMINI || localStorage.getItem('geminiKey') || '';
  if (!gkey) throw new Error('Gemini key missing.');

  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${gkey}`;
  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: { responseMimeType: 'application/json', temperature: 0.2 }
  };

  try {
    const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      if (response.status === 429 && retryCount === 0) {
        await new Promise(r => setTimeout(r, 30000)); // rate limit backoff
        return callLLMAPI(prompt, model, 1);
      }
      throw new Error(error.error?.message || `Gemini API error ${response.status}`);
    }
    const data = await response.json();
    const part = data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!part) throw new Error('Gemini response malformed.');
    const parsed = parseJSONLoose(part);
    if (parsed !== null) return parsed;
    throw new Error('Failed to parse any valid JSON from the Gemini response.');
  } catch (e) {
    if (retryCount === 0 && String(e.message || '').includes('fetch')) {
      await new Promise(r => setTimeout(r, 30000));
      return callLLMAPI(prompt, model, 1);
    }
    throw e;
  }
}

async function generateTagsFromContent() {
  const text  = documentInput.value || '';
  const cards = acceptedFlashcards || [];
  const domainRule = window.WRITING_RULES[styleSelect?.value] || {};

  const prompt = `
You are a precise tagger. Examine the DOCUMENT and (if helpful) the accepted FLASHCARDS.
Return ONLY a JSON array (3–10 strings) of lowercase hyphen-separated tags based on Wikipedia's academic disciplines taxonomy (e.g., "reference-material", "formal-science", "computer-science", "ai", "economics", "history-of-science").
Avoid duplicates; be specific but not obscure.

DOCUMENT (excerpted if long):
\`\`\`
${text.slice(0, 5000)}
\`\`\`

FLASHCARDS (front/back pairs, excerpted if many):
\`\`\`
${cards.slice(0, 40).map(c => `Q: ${c.front}\nA: ${c.back}`).join('\n\n')}
\`\`\`
`;

  const model = getModelForType('flashcard'); // a strong model is helpful here
  const result = await callLLMAPI(prompt, model);
  let arr = Array.isArray(result) ? result : [];
  // normalize to kebab-case and dedupe
  arr = arr
    .map(s => String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g,''))
    .filter(Boolean);

  // de-dupe while preserving order
  const seen = new Set();
  cachedTags = arr.filter(t => (seen.has(t) ? false : seen.add(t)));

  // quick preview
  if (tagsPreview) {
    tagsPreview.innerHTML = cachedTags.length
      ? `Tags: ${cachedTags.map(t => `<code>${t}</code>`).join(' ')}`
      : 'No tags generated yet.';
  }
  return cachedTags;
}

if (genTagsNowBtn) genTagsNowBtn.addEventListener('click', async () => {
  tagsPreview.textContent = 'Generating…';
  try { await generateTagsFromContent(); } catch (e) { tagsPreview.textContent = 'Failed to generate tags.'; }
});

async function renderExportAsync() {
  const styleKey   = (exportStyleSelect?.value) || localStorage.getItem('exportStyle') || 'neuracache';
  const formatter  = EXPORTERS[styleKey] || EXPORTERS.neuracache;
  const includeSrc = (includeSourceCheckbox?.checked !== undefined)
    ? includeSourceCheckbox.checked
    : JSON.parse(localStorage.getItem('exportIncludeSource') || 'false');

  // Base body: just the cards
  let body = formatter(acceptedFlashcards || []);

  if (includeSrc) {
    const src = documentInput.value || '';
    body = `## Source Material\n${src}\n\n## Flashcards\n${body}`;
  }

  // Front-matter?
  const wantMeta = includeMetadataCheckbox?.checked
    ?? JSON.parse(localStorage.getItem('exportIncludeMetadata') || 'false');

  if (!wantMeta) return body;

  // Ensure created/modified timestamps
  if (!createdAtISO) {
    createdAtISO = new Date().toISOString().slice(0,16).replace('T',' ');
    localStorage.setItem('exportCreatedAt', createdAtISO);
  }
  const modifiedISO = new Date().toISOString().slice(0,16).replace('T',' ');

  // Ensure tags if requested
  let tags = [];
  const wantTags = generateTagsCheckbox?.checked
    ?? JSON.parse(localStorage.getItem('exportGenerateTags') || 'false');

  if (wantTags) {
    if (!cachedTags || cachedTags.length === 0) {
      try { await generateTagsFromContent(); } catch {}
    }
    tags = cachedTags || [];
  }

  const author = metaAuthorInput?.value?.trim() || localStorage.getItem('exportAuthor') || '';
  const deck   = metaDeckInput?.value?.trim()   || localStorage.getItem('exportDeck')   || '';

  const tpl = metadataTemplate?.value || localStorage.getItem('metadataTemplate') || '';
  const frontMatter = buildMetadataBlock(tpl, author, deck, createdAtISO, modifiedISO, tags);

  return `${frontMatter}\n\n${body}`;
}



function parseJSONLoose(text) {
  if (!text || typeof text !== 'string') return null;

  // 1) Code fences
  const fence = text.match(/```json\s*([\s\S]*?)```/i) || text.match(/```\s*([\s\S]*?)```/);
  if (fence) {
    try { return JSON.parse(fence[1]); } catch {}
  }

  // 2) Direct parse
  try { return JSON.parse(text); } catch {}

  // 3) Bracket cropping: get biggest {...} or [...]
  const firstObj = text.indexOf('{');
  const lastObj  = text.lastIndexOf('}');
  const firstArr = text.indexOf('[');
  const lastArr  = text.lastIndexOf(']');

  const candidates = [];
  if (firstArr !== -1 && lastArr > firstArr) candidates.push(text.slice(firstArr, lastArr + 1));
  if (firstObj !== -1 && lastObj > firstObj) candidates.push(text.slice(firstObj, lastObj + 1));

  for (const c of candidates) {
    try { return JSON.parse(c); } catch {}
  }

  return null;
}

async function handleAnalysis() {
  clearUserSelection();
  const currentText = documentInput.value;
  if (!currentText.trim()) {
    alert('Please enter some text to analyze.');
    return;
  }
  
  const selectedRule = window.WRITING_RULES[ruleSelect.value];
  if (!selectedRule) {
    alert('Please select a rule.');
    return;
  }
  
  resetState();
  loadingOverlay.style.display = 'flex';
  
  try {
    // Extract LaTeX content if applicable
    const extractedText = extractLatexContent(currentText);
    
    // Split text into chunks
    const depth = (typeof depthSelect !== 'undefined' ? depthSelect.value : 'medium');
    const maxChunk = depth === 'complete' ? 12000 : 30000;   // tighter chunks for dense outputs
    const chunks = splitTextIntoChunks(extractedText, maxChunk);
    
    const model = getModelForType(selectedRule.type);
    loadingText.textContent = `Analyzing with ${selectedRule.name}...`;
    
    const allCorrections = [];

    // Process each chunk
    for (let i = 0; i < chunks.length; i++) {
      loadingText.textContent = `Analyzing part ${i + 1} of ${chunks.length}...`;
      
      const prompt = generatePrompt(chunks[i], selectedRule);
      const results = await callLLMAPI(prompt, model);
      
      if (Array.isArray(results)) {
        allCorrections.push(...results);
      }
    }

    // Map results to positions in the original document
    let searchFromIndex = 0;
    const mappedCorrections = [];
    const snippetKey = (selectedRule.type === 'flashcard') ? 'source' : 'original';

    for (const corr of allCorrections) {
      if (!corr || typeof corr[snippetKey] !== 'string' || corr[snippetKey].length === 0) {
        console.warn("Skipping invalid object from API:", corr);
        continue;
      }
      const foundAtIndex = currentText.indexOf(corr[snippetKey], searchFromIndex);
      if (foundAtIndex !== -1) {
        corr.position = { start: foundAtIndex, end: foundAtIndex + corr[snippetKey].length };
        if (selectedRule.type === 'flashcard') {
          corr.type = 'flashcard';
          corr.front = (typeof corr.front === 'string') ? corr.front : '';
          corr.back  = (typeof corr.back  === 'string') ? corr.back  : '';
          corr.explanation = (typeof corr.explanation === 'string') ? corr.explanation : '';
        }
        mappedCorrections.push(corr);
        searchFromIndex = corr.position.end;
      } else {
        console.warn(`Could not anchor object using "${corr[snippetKey]}"`);
      }
    }
    corrections = mappedCorrections;

    if (corrections.length > 0) {
      documentInput.readOnly = true;        // Prevent typing
      // documentInput.classList.add('locked'); // <-- LOCK MOUSE EVENTS
      currentIndex = 0;
      updateActiveCorrection();
    } else {
        // No corrections found, so ensure it's not locked
        documentInput.readOnly = false;
        documentInput.classList.remove('locked');
        highlightOverlay.innerHTML = escapeHtml(currentText) + `<div class="empty-state"><h3>No suggestions found</h3><p>Your document looks great!</p></div>`;
    }

  } catch (error) {
    alert(`Analysis failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
    loadingText.textContent = 'Analyzing...';
  }
} 

async function handleSimplification() {
  if (!selectedText || !selectedRange) return;
  
  loadingOverlay.style.display = 'flex';
  loadingText.textContent = 'Generating simplifications...';
  
  try {
    const model = getModelForType('simplify');
    const fullText = documentInput.value;
    
    // Get context (1000 chars before and after)
    const contextStart = Math.max(0, selectedRange.start - 1000);
    const contextEnd = Math.min(fullText.length, selectedRange.end + 1000);
    const context = fullText.substring(contextStart, contextEnd);
    
    const prompt = generateSimplificationPrompt(selectedText, context);
    const result = await callLLMAPI(prompt, model);
    
    // Display simplification options in modal
    displaySimplifications(result);
    
  } catch (error) {
    alert(`Simplification failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function handleProofCheck() {
  if (!selectedText || !selectedRange) return;
  
  loadingOverlay.style.display = 'flex';
  loadingText.textContent = 'Checking proof validity...';
  
  try {
    const model = getModelForType('proof');
    const fullText = documentInput.value;
    
    const prompt = generateProofCheckPrompt(selectedText, fullText);
    const result = await callLLMAPI(prompt, model);
    
    // Display proof check results in summary modal
    displayProofCheck(result);
    
  } catch (error) {
    alert(`Proof check failed: ${error.message}`);
    console.error(error);
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

function displayProofCheck(result) {
  let html = '';
  
  html += `<div class="summary-section">
    <h3>Validity</h3>
    <p><strong>${result.is_valid ? 'Valid' : 'Invalid or Incomplete'}</strong></p>
  </div>`;
  
  if (result.overall) {
    html += `<div class="summary-section">
      <h3>Overall Assessment</h3>
      <p>${escapeHtml(result.overall)}</p>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.issues && result.issues.length > 0) {
    html += `<div class="summary-section">
      <h3>Issues Found</h3>
      <ul>${result.issues.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.questions && result.questions.length > 0) {
    html += `<div class="summary-section">
      <h3>Clarifying Questions</h3>
      <ul>${result.questions.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Use JSON.stringify for objects
  if (result.suggestions && result.suggestions.length > 0) {
    html += `<div class="summary-section">
      <h3>Suggestions</h3>
      <ul>${result.suggestions.map(item => `<li>${typeof item === 'object' ? JSON.stringify(item, null, 2) : item}</li>`).join('')}</ul>
    </div>`;
  }
  
  // Update the summary modal title temporarily
  const modalTitle = summaryModal.querySelector('h2');
  const originalTitle = modalTitle.textContent;
  modalTitle.textContent = 'Proof Validity Check';
  
  summaryContent.innerHTML = html;
  summaryModal.classList.add('visible');
  modalOverlay.classList.add('visible');
  
  // Restore original title when modal closes
  const restoreTitle = () => {
    modalTitle.textContent = originalTitle;
    modalOverlay.removeEventListener('click', restoreTitle);
    summaryClose.removeEventListener('click', restoreTitle);
  };
  modalOverlay.addEventListener('click', restoreTitle);
  summaryClose.addEventListener('click', restoreTitle);
}

function displaySimplifications(options) {
  // Set original text
  simplificationOriginal.textContent = selectedText;
  
  let html = '';
  
  const variants = [
    { key: 'same_length', label: 'Same Length (Simpler Language)' },
    { key: 'moderate', label: 'Moderately Shorter (~30% reduction)' },
    { key: 'concise', label: 'Much Shorter (~50-60% reduction)' }
  ];
  
  variants.forEach(variant => {
    if (options[variant.key]) {
      html += `
        <div class="simplification-option" data-text="${options[variant.key].replace(/"/g, '&quot;')}">
          <div class="simplification-label">${variant.label}</div>
          <div class="simplification-text">${escapeHtml(options[variant.key])}</div>
        </div>
      `;
    }
  });
  
  simplificationOptions.innerHTML = html;
  
  // Add click handlers
  document.querySelectorAll('.simplification-option').forEach(option => {
    option.addEventListener('click', () => {
      const newText = option.getAttribute('data-text').replace(/&quot;/g, '"');
      replaceSelectedText(newText);
      closeSimplificationModal();
    });
  });
  
  // Show modal
  simplificationModal.classList.add('visible');
  simplificationOverlay.classList.add('visible');
}

function replaceSelectedText(newText) {
  if (!selectedRange) return;
  
  const currentText = documentInput.value;
  const before = currentText.substring(0, selectedRange.start);
  const after = currentText.substring(selectedRange.end);
  
  documentInput.value = before + newText + after;
  
  clearUserSelection();
}

function closeSimplificationModal() {
  simplificationModal.classList.remove('visible');
  simplificationOverlay.classList.remove('visible');
}

function closeSummaryModal() {
  summaryModal.classList.remove('visible');
  modalOverlay.classList.remove('visible');
}

function updateHighlightOverlay() {
  const currentText = documentInput.value;
  const hasSelection = selectionMode && selectedRange;
  const needOverlay = hasSelection || (corrections.length > 0);

  if (!needOverlay) {
    highlightOverlay.innerHTML = '';
    highlightOverlay.style.display = 'none';
    document.getElementById('mainContent')?.classList.remove('overlay-active');
    documentInput.style.height = 'auto';
    adjustTextareaHeight();
    return;
  }

  highlightOverlay.style.display = 'block';
  document.getElementById('mainContent')?.classList.add('overlay-active');

  // 1) Group corrections by identical anchor
  const groupsMap = new Map();
  corrections.forEach((c, i) => {
    if (!c?.position) return;
    const key = `${c.position.start}:${c.position.end}`;
    if (!groupsMap.has(key)) groupsMap.set(key, { start: c.position.start, end: c.position.end, idxs: [] });
    groupsMap.get(key).idxs.push(i);
  });
  const groups = Array.from(groupsMap.values()).sort((a,b) => (a.start - b.start) || (a.end - b.end));

  // 2) Build render segments = { type:'selection'|'group', start, end, ... }
  const segments = [];
  if (hasSelection) {
    segments.push({ type: 'selection', start: selectedRange.start, end: selectedRange.end });
  }
  for (const g of groups) {
    // While selecting, suppress only chips that overlap the selection
    if (hasSelection && g.start < selectedRange.end && g.end > selectedRange.start) continue;
    segments.push({ type: 'group', start: g.start, end: g.end, idxs: g.idxs });
  }

  // 3) Sort by start (stable forward pass)
  segments.sort((a, b) => (a.start - b.start) || (a.end - b.end));

  // 4) Emit markup in one forward sweep
  let html = '';
  let lastPos = 0;

  for (const seg of segments) {
    if (seg.start > lastPos) {
      html += escapeHtml(currentText.substring(lastPos, seg.start));
    }
    if (seg.type === 'selection') {
      html += `<mark class="user-selection">${escapeHtml(currentText.substring(seg.start, seg.end))}</mark>`;
    } else {
      const originalText = currentText.substring(seg.start, seg.end);
      const firstIndex = seg.idxs[0];
      const groupAttr  = seg.idxs.join(',');
      html += `<mark class="suggestion" data-index="${firstIndex}" data-group="${groupAttr}">` +
              `${escapeHtml(originalText)}${seg.idxs.length > 1 ? `<sup class="badge">×${seg.idxs.length}</sup>` : ''}` +
              `</mark>`;
    }
    lastPos = seg.end;
  }
  if (lastPos < currentText.length) {
    html += escapeHtml(currentText.substring(lastPos));
  }

  highlightOverlay.innerHTML = html;
  documentInput.style.height = highlightOverlay.offsetHeight + 'px';

  // 5) Click handlers for chips (unchanged)
  document.querySelectorAll('.suggestion').forEach(mark => {
    mark.addEventListener('click', (e) => {
      const group = (e.currentTarget.dataset.group || '')
        .split(',').map(n => parseInt(n,10)).filter(n => !isNaN(n));
      if (group.length <= 1) {
        currentIndex = parseInt(e.currentTarget.dataset.index, 10);
      } else {
        const pos = group.indexOf(currentIndex);
        const next = (pos === -1 || pos === group.length - 1) ? group[0] : group[pos + 1];
        currentIndex = next;
      }
      updateActiveCorrection();
    });
  });
}


function escapeHtml(text) {
  if (typeof text !== 'string') return '';
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function adjustTextareaHeight() {
  // Auto-size the textarea when overlay is not active
  documentInput.style.height = 'auto';
  documentInput.style.height = documentInput.scrollHeight + 'px';
}

// --- Reverse-card helpers ---
function looksMetaQuestion(s) {
  if (!s) return false;
  const t = s.toLowerCase();
  return /what question|which question|would give the answer|given the answer|answer would be/.test(t);
}

function tryHeuristicReverse(card) {
  // Patterns: "types of X", "examples of X"
  const front = (card.front || '').toLowerCase();
  const m1 = front.match(/types?\s+of\s+(.+?)[\.\?]*$/i);
  const m2 = front.match(/examples?\s+of\s+(.+?)[\.\?]*$/i);
  const concept = (m1 && m1[1]) || (m2 && m2[1]) || null;

  if (concept) {
    const examples = (card.back || '').replace(/\s+/g, ' ').trim();
    const frontRev = `${examples} are ${m2 ? 'examples' : 'types'} of what?`;
    return {
      source: card.source || '',
      front: frontRev,
      back: concept.trim(),
      explanation: 'Heuristic reverse from "types/examples of X".'
    };
  }
  // Fallback generic swap if nothing better
  return {
    source: card.source || '',
    front: (card.back || '').trim(),
    back: (card.front || '').trim(),
    explanation: 'Quick reverse (swap) due to unrecognized pattern.'
  };
}


function updateActiveCorrection() {
    if (currentIndex < 0 || currentIndex >= corrections.length) {
        hidePopover();
        return;
    }

    updateHighlightOverlay();
    requestAnimationFrame(() => {
       let activeMark = highlightOverlay.querySelector(`.suggestion[data-index="${currentIndex}"]`);
        if (!activeMark) {
          // Find any group that contains this index
          activeMark = Array.from(highlightOverlay.querySelectorAll('.suggestion'))
            .find(el => (el.dataset.group || '').split(',').includes(String(currentIndex)));
        }
       if (activeMark) {
           activeMark.classList.add('active');
           showPopoverFor(activeMark);
           activeMark.scrollIntoView({ behavior: 'smooth', block: 'center' });
       }
    });
    
    updateNavigation();
}

function showPopoverFor(element) {
  if (selectionMode) return; // don't show the popover during a user text selection
  const correction = corrections[currentIndex];
  if (!correction) return;

  if (correction.type === 'flashcard') {
    popoverExplanation.textContent = correction.explanation ||
    'Edit the card (Front/Back) and press Enter to accept, or Backspace/Delete to reject.';
    popoverOriginal.setAttribute('contenteditable', 'true');
    popoverCorrected.setAttribute('contenteditable', 'true');
    popoverOriginal.textContent = correction.front || '';
    popoverCorrected.textContent = correction.back || '';
  } else {
    popoverExplanation.textContent = correction.explanation || '';
    popoverOriginal.removeAttribute('contenteditable');
    popoverCorrected.setAttribute('contenteditable', 'true');
    popoverOriginal.textContent = correction.original || '';
    popoverCorrected.textContent = correction.corrected || '';
  }

  suggestionPopover.classList.add('visible');
  element.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// --- Dynamic editing hint updates ---
function updateEditingHint(isEditing) {
  if (!popoverExplanation) return;
  if (isEditing) {
    popoverExplanation.textContent =
      'While editing, press Ctrl/Cmd + Enter to accept, or Ctrl/Cmd + Backspace/Delete to reject.';
  } else {
    popoverExplanation.textContent =
      'Edit the card (Front/Back) and press Ctrl/Cmd + Enter to accept, or Ctrl/Cmd + Backspace/Delete to reject.';
  }
}

// When either field gains or loses focus, update the hint
[popoverOriginal, popoverCorrected].forEach(el => {
  el.addEventListener('focus', () => updateEditingHint(true));
  el.addEventListener('blur',  () => updateEditingHint(false));
});

function hidePopover() {
    suggestionPopover.classList.remove('visible');
    document.querySelectorAll('.suggestion.active').forEach(el => el.classList.remove('active'));
}

function navigateCorrections(direction) {
    if (corrections.length === 0) return;
    
    const newIndex = currentIndex + direction;
    
    if (newIndex >= 0 && newIndex < corrections.length) {
        currentIndex = newIndex;
        updateActiveCorrection();
    }
}

function updateNavigation() {
    const correctionControls = document.getElementById('correctionControls');
    
    // Handle Correction Navigation
    if (corrections.length > 0 && currentIndex > -1) {
        correctionControls.style.display = 'flex';
        navInfo.textContent = `${currentIndex + 1} / ${corrections.length}`;
        prevBtn.disabled = currentIndex <= 0;
        nextBtn.disabled = currentIndex >= corrections.length - 1;
    } else {
        correctionControls.style.display = 'none';
    }

    const isCard = corrections.length > 0 && currentIndex > -1 && corrections[currentIndex].type === 'flashcard';
    if (regenBtn)   regenBtn.style.display   = isCard ? 'inline-block' : 'none';
    if (splitBtn)   splitBtn.style.display   = isCard ? 'inline-block' : 'none';
    if (reverseBtn) reverseBtn.style.display = isCard ? 'inline-block' : 'none';
    if (newFromHighlightBtn) newFromHighlightBtn.style.display = isCard ? 'inline-block' : 'none';

    // Handle Selection Actions
    if (selectionMode && selectedText) {
        selectionActions.style.display = 'flex';
        const proofKeywords = /\\(?:theorem|proposition|lemma|proof)|\b(?:theorem|proposition|lemma|proof)\b/i;
        const hasProofContent = proofKeywords.test(selectedText);
        proofBtn.style.display = hasProofContent ? 'block' : 'none';
    } else {
        selectionActions.style.display = 'none';
    }
}

function acceptCorrection(index) {
  if (index < 0 || index >= corrections.length) return;

  const correction = corrections[index];

  // FLASHCARD MODE
  if (correction.type === 'flashcard') {
    const front = (popoverOriginal.textContent || '').trim();
    const back  = (popoverCorrected.textContent || '').trim();

    undoStack.push({
      action: 'accept_card',
      correction: { ...correction },
      index,
      card: { front, back },
      textBefore: documentInput.value
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    acceptedFlashcards.push({ front, back });
    updateFlashcardsOutput();

    corrections.splice(index, 1);
    if (corrections.length === 0) {
      resetState();
    } else {
      currentIndex = Math.min(index, corrections.length - 1);
      updateActiveCorrection();
    }
    return;
  }

  // LEGACY path (grammar/style) if you keep them
  const editedCorrectionText = popoverCorrected.textContent;
  const lengthDiff = editedCorrectionText.length - (correction.position.end - correction.position.start);
  undoStack.push({
    action: 'accept',
    correction: { ...correction },
    index: index,
    textBefore: documentInput.value,
    lengthDiff: lengthDiff
  });
  undoBtn.style.display = 'flex';

  redoStack.length = 0;
  if (redoBtn) redoBtn.style.display = 'none';

  let currentText = documentInput.value;
  currentText = currentText.substring(0, correction.position.start) +
               editedCorrectionText +
               currentText.substring(correction.position.end);
  documentInput.value = currentText;

  corrections.splice(index, 1);
  for (let i = index; i < corrections.length; i++) {
    corrections[i].position.start += lengthDiff;
    corrections[i].position.end += lengthDiff;
  }

  if (corrections.length === 0) resetState();
  else { currentIndex = Math.min(index, corrections.length - 1); updateActiveCorrection(); }
}

function rejectCorrection(index) {
  if (index < 0 || index >= corrections.length) return;

  const item = corrections[index];
  if (item.type === 'flashcard') {
    // --- UNDO for rejecting a card suggestion ---
    undoStack.push({
      action: 'reject_card',
      correction: { ...item },
      index,
      // textBefore is unchanged but safe to keep
      textBefore: documentInput.value
    });
    undoBtn.style.display = 'flex';

    redoStack.length = 0;
    if (redoBtn) redoBtn.style.display = 'none';

    corrections.splice(index, 1);
    if (corrections.length === 0) {
      resetState();
      updateHighlightOverlay();
    } else {
      currentIndex = Math.min(index, corrections.length - 1);
      updateActiveCorrection();
    }
    return;
  }

  // Existing legacy (grammar/style) path...
  // (your current code continues here)
}

// Modal functions
function showAboutModal() {
  aboutModal.classList.add('visible');
  aboutOverlay.classList.add('visible');
}

function closeAboutModal() {
  aboutModal.classList.remove('visible');
  aboutOverlay.classList.remove('visible');
}

function showFileModal() {
  fileModal.classList.add('visible');
  fileOverlay.classList.add('visible');
}

function closeFileModal() {
  fileModal.classList.remove('visible');
  fileOverlay.classList.remove('visible');
  dropZone.classList.remove('dragging');
}


// File handling functions
function handleDragOver(e) {
  e.preventDefault();
  dropZone.classList.add('dragging');
}

function handleDragLeave(e) {
  e.preventDefault();
  dropZone.classList.remove('dragging');
}

function handleDrop(e) {
  e.preventDefault();
  dropZone.classList.remove('dragging');
  
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    processFile(files[0]);
  }
}

function handleFileSelect(e) {
  const files = e.target.files;
  if (files.length > 0) {
    processFile(files[0]);
  }
}

function processFile(file) {
  // Check file extension
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.tex') && !fileName.endsWith('.txt')) {
    alert('Please select a .tex or .txt file');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    documentInput.value = e.target.result;
    updateHighlightOverlay();
    closeFileModal();
    resetState();
    adjustTextareaHeight();
  };
  reader.onerror = function() {
    alert('Error reading file');
  };
  reader.readAsText(file);
}

</script>

</body>
</html>